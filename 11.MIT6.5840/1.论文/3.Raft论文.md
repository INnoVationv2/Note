# Raft

# CH-1

PAXOS很难理解,所以发明了Raft，解决这个问题

# CH-2 

> 复制状态机简介

1. Replicated state machines常用在分布式环境，解决多节点数据一致性问题
2. 使用replicated log，所有的节点都会获得log，log中的内容和顺序都相同，当所有节点执行完相同的log后，就会得到相同的结果。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425120056892.png" alt="image-20230425120056892" style="zoom:50%;" align="left"/>

3. 一致性算法的主要工作就是保证所有节点获取到的log的都一样
4. 通常来讲，一个一致性算法包含以下属性
   1. 在非拜占庭环境下，保证返回正确的结果。
   2. 只要集群中的多数还存活，能够彼此沟通以及和Client沟通，那么集群就应能够正常工作，比如一个5节点集群能够容忍任意2个节点的失效，失效节点在任意时间都可恢复状态并重新加入集群。
   3. 不依靠时间属性保证log的一致性，时钟信息错误或消息延迟最多造成有效性问题，而不是状态错误的问题。
   4. 一般情况下，对于一条指令，当集群中的多数都执行完成时，这条指令就是执行完成的状态，少数节点的延迟不影响整体。

>拜占庭环境:
>
>拜占庭故障是指一个节点在分布式系统中以恶意方式进行操作，比如向其他节点发送虚假、错误的信息，试图破坏系统的一致性和可靠性。
>
>在Raft论文中，作者假设系统中的节点不会出现拜占庭故障。他们关注的是一些常见的故障情况，如节点崩溃、网络分区、消息延迟等。这些故障可以由诸如硬件故障、网络故障或软件错误等原因引起。

## 状态

| 所有server都有的持久化状态           | 先存储，然后响应RPC                                          |
| ------------------------------------ | ------------------------------------------------------------ |
| currentTerm                          | 当前任期，初始为0                                            |
| votedFor                             | 当前任期自己投的候选人的`candidateId`，没有就是null          |
| log[]                                | log条目集，每个条目都包含状态机的命令，以及Leader收到条目时的任期，首个条目的index为1 |
| **所有server都有的Volatile state：** |                                                              |
| commitIndex                          | 被提交的最大日志条目的index，初始为0                         |
| lastApplied                          | 被应用到状态机的日志条目的index，初始为0                     |
| **Leader独有的Volatile state:**      |                                                              |
| nextIndex[]                          | 对于每个server，下次要发送的日志条目的起始index，起始为`Leader last log index + 1` |
| matchIndex[]                         | 对于每个server，已复制的最高日志条目的index，初始为0。       |

## AppendEntries RPC，用于追加日志

> 1. 由Leader发起，发送给follower，用于复制日志条目(§5.3)
> 2. 也用于心跳连接(§5.2)

| Arguments    |                                                             |
| ------------ | ----------------------------------------------------------- |
| term         | Leader 任期                                                 |
| leaderId     | follower可通过这个重定向其他client的请求到Leader            |
| prevLogIndex | 前一个日志的index                                           |
| prevLogTerm  | 前一个日志的term                                            |
| entries[]    | 日志条目，心跳时为空                                        |
| leaderCommit | leader的commit Index                                        |
| **Results:** |                                                             |
| term         | 用于Leader的更新                                            |
| success      | 如果follower的日志和prevLogIndex、prevLogTerm匹配就返回true |

**Receiver implementation**

1. 如果Leader的任期小于follower的任期，返回false

2. 如果follower和`prevLogIndex`、`prevLogTerm`匹配失败，返回false

3. 如果follower的日志和Leader发来的日志冲突（比如相同的index，不同的任期），则删除自己的日志，用Leader发来的替换掉。

4. 只添加没有的日志

5. `If leaderCommit > commitIndex：`

    `set commitIndex = min(leaderCommit, index of last new entry)`

## RequestVote RPC

> 由候选者发起，收集投票(§5.2).

| Arguments    | -                                   |
| ------------ | ----------------------------------- |
| term         | 候选者的当前任期                    |
| candidateId  | 用以说明谁在请求选票                |
| lastLogIndex | 候选者最后一个日志项目的index(§5.4) |
| lastLogTerm  | 候选者最后一个日志项目的任期(§5.4)  |
| **Result**   |                                     |
| term         | 当前任期                            |
| voteGranted  | 是否投票                            |

**Receiver implementation:**

1. `if term < currentTerm: return false`(§5.1)
2. 如果`votedFor`是 null 或 candidateId，并且候选人与接收人的日志一样是最新的，则投票(§5.2, §5.4)。

## Rules for Servers

**All Servers:**

1. `If commitIndex > lastApplied`: 增加lastApplied，将log应用到状态机(§5.3)
2. 如果RPC的请求或者回复中包含的term大于自身term：则更新自己的term，并将自己转为follower状态(§5.1)

**Followers:**

1. 回应来自候选人和leader的RPC
2. 如果选举超时，没有收到现任Leader的AppendEntries RPC，也没有投票出去(不是收到投票请求，是投票出去)时，转换为候选人

**Candidates:**

1. 转换为候选人状态后，启动选举：
   - 增加当前任期
   - 投票给自己
   - 重置选举超时时间
   - 发送RequestVote RPC给其他所有服务器
2. 如果收到了超过半数的投票，成为Leader
3. 如果RPC被Leader接收到，停止选举，转换回follower
4. 如果选举时超时，再次启动选举

**Leaders:**

1. 当选举完成后：向每个服务器发送初始的空AppendEntries RPC(心跳)；在空闲期间重复发送以防止选举超时。(§5.2)
2. 如果收到来自客户端的指令: 添加指令到本地日志，待条目应用到状态机后再响应(§5.3)
3. If last log index ≥ nextIndex for a follower: 发送 AppendEntries RPC 并附上从nextIndex开始的 log entries 
   - If successful: 更新 nextIndex 和 matchIndex (§5.3)
   - If AppendEntries fails because of log inconsistency: 减小nextIndex并重试(§5.3)
4. 如果存在一个N，使得N>commitIndex，大多数的matchIndex[i]≥N，并且log[N].term == currentTerm：设置commitIndex = N (§5.3, §5.4).

# CH-3

> Paxos的缺陷

- 不好用
- 不好理解

# CH-4

> 设计Raft时，为了容易理解做了哪些努力

# CH-5

> Raft算法介绍

## 5.1 Raft概述

1. 首先通过选举，选出一个特定节点做Leader，将`管理日志`的职责全部交给该Leader。

2. Leader接收来自客户端的日志条目，并将其复制到其他服务器， 在安全时告知客户端将日志条目应用于其状态机。

   拥有Leader简化了复制日志的管理。例如，Leader可以决定将新条目在日志中放置的位置，而无需咨询其他服务器，并且数据只从Leader流向客户端，简单明了。

   Leader可能会失效，或与其他服务器断开连接，在这种情况下系统会选出新的Leader
   

Raft将一致性问题分解为三个相对独立的子问题

  - Leader选举：现有Leader失效时，必须选出一个新的Leader
  - 日志复制：Leader必须接受来自客户端的日志条目，并在集群中进行复制，让Client的日志与自己的日志一致
  - 安全性：如果任一服务器对其状态机应用了一条日志，那么其他服务器必须应用相同的日志到相同位置。5.4节描述了Raft如何确保这一属性

## 5.1 基础概念

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230516181832398.png" alt="image-20230516181832398" style="zoom:50%;" align="left"/>

- 集群一般包含多个服务器，通常为五个，这样可以容忍任意两个发生故障。

- 每个服务器的状态都是以下三种之一：
  - Leader：集群中只会有一个，处理所有客户端请求（如果客户端联系Follower，Follower会将其重定向到Leader）。
  
  - Follower：不会主动发出请求，只被动的响应Leader和候选人的请求。
  
  - Candidate：Leader候选人
  
    <img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425151508108.png" style="zoom:50%;" align="left"/>

上图展示了服务器的所有状态及其转换。

在Raft中，任期编号充当逻辑时钟，帮助服务器检测信息是否过时，如过时的Leader，每个服务器都会存储当前的任期编号，该编号单调递增。在服务器之间通信时，会交换当前任期号：如果一个服务器的当前任期小于其他服务器的任期，则它会更新自己的任期号。如果Candidate或Leader发现其任期过时，它将立刻退回到Follower状态。如果服务器收到带有过时任期编号的请求，则会拒绝该请求。Raft服务器之间使用RPC进行通信，要实现基本共识算法，仅需要以下类型的RPC。

- RequestVote RPC：由Follower在选举时发起
- AppendEntries RPC：由Leader发起，用于复制日志条目并提供心跳服务（第5.3节）。

第7节添加了第三种用于在服务器之间传输快照的RPC。如果服务器未及时接收到响应，它们会重试RPC，并且会并行发出RPC以获得最佳性能。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425152532222.png" alt="image-20230425152532222" style="zoom:50%;" align="left"/>

> 图5：时间被分成了任期，每个任期都以选举开始。选举将产生一个Leader，它将管理集群直到任期结束。有时选举会失败、

## 5.2 Leader选举流程

**0.新服务器加入集群**

服务器在启动时状态是Follower。如果此时服务器接收到Leader或Candidate的心跳信息，就会继续保持Follower状态。

**1.开始选举：**

Follower通过一个称为`选举超时(election timeout)`的时间间隔来决定是否启动选举。

如果选举超时时间超时，未收到有效的心跳（不包含日志条目的AppendEntries RPC），则认为当前没有可用的Leader，开启选举。

**2.谁成为Candidate：**

谁超时，谁就是候选者

Follower在发生超时后，会把自己状态变为Candidate，增加自己的任期值(term)，并为自己投票。同时向集群中的其他服务器发送 RequestVote RPC，请求选票。

**3.投票规则**

当服务器收到 RequestVote RPC 时，它们会根据以下规则进行投票：

- 如果收到的 RPC 的任期小于服务器当前的任期：拒绝投票。
- 如果服务器已经为当前任期投过票，或收到的 RPC 中的日志不如自己的日志新（即最后一个条目的任期较旧或者任期相同但是编号较小），那么服务器也会拒绝投票。
- 如果以上条件都不满足，服务器会为候选人投票，并重置自己的选举超时时间。

**4.选举结果**

- 如果候选人获得了集群中大多数服务器的选票，那么候选人赢得选举，立即成为新的Leader。它会向所有其他服务器发送心跳消息，以防止新的选举。
- 如果在选举过程中，候选人收到了来自其他服务器的心跳信息，且该服务器的任期大于等于候选人的任期，那么候选人会承认新Leader的合法性并转回Follower状态。
- 如果选举超时，且没有选出Leader，那么候选人会重置超时时间并触发新一轮选举。

## 5.3 日志复制

### 复制流程

1. **客户端请求**：一旦成为Leader，就开始处理客户端请求。每个客户端请求包含一个要由复制状态机执行的命令。
2. **追加到Leader日志：**Leader将客户端请求中的命令作为新条目追加到自己的日志中。此日志条目包含要执行的命令和任期编号。
3. **复制日志条目：**Leader并行地向所有Follower发送 AppendEntries RPC，其中包含待复制的日志条目、新条目前一个日志条目的索引和任期。
4. **复制确认**：Follower收到 AppendEntries RPC 后，首先检查其中的前一个日志条目的索引和任期数据是否与自己的日志相匹配。如果匹配，Follower会添加新条目，并回复成功。如果不匹配，Follower将拒绝并回复失败。
5. **safely replicated：**一旦Leader收到大多数Follower(包括Leader在内的半数以上，比如5个中的3个，6个中的4个)的确认，日志条目就被认为是safely replicated。
6. **提交：** 当日志条目safely replicated后，Leader会将这个条目到自己的状态机，即Commited，提交之后，它并不直接向跟随者节点发送命令以提交该条目，他只会更新已提交的最大索引编号，在下次与follower沟通时，把最大index附上，这样follower就知道该索引之前的所有条目都已提交。
7. **返回结果**：Leader在应用已提交日志条目到状态机后，会将操作结果返回给客户端。此时，分布式系统中的大多数服务器已达成一致并成功执行了客户端请求的操作。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425171710770.png" alt="image-20230425171710770" style="zoom:50%;" align="left"/>

<div align="center"><font color="green">图6：日志由按顺序编号的条目组成。每个条目包含创建它的任期（方框中的数字）和命令信息。如果一个条目可以安全地应用于状态机，那么它被认为是已提交的。</font></div>

### AppendEntries RPC中的元素

1. **Term**: 任期，用于检测Leader是否有效
2. **Leader ID**: Leader的标识符，以便Follower能够重定向客户端。
3. **PrevLogIndex**: 紧接在新日志之前的日志条目的索引
4. **PrevLogTerm**: 紧接在新日志之前的日志条目的任期，和PrevLogIndex结合. 用于检查Leader和跟随者之间的日志是否一致。
5. **Entries[]**:  日志条目。心跳时这个可能是空的，这是一种特殊的AppendEntries RPC，不包含任何新的条目。
6. **LeaderCommit**:  Leader执行过的日志的最大Index。Follower会将这个Index及之前的日志应用于其状态机

返回给Leader的元素

1. **Term**: Follower的当前任期，供Leader自我更新。
2. **Success**:一 个布尔值，表示Follower的日志条目是否与Leader的条目相匹配。如果吻合，跟随者会添加新的条目。如果不匹配，跟随者拒绝RPC，Leader将递减prevLogIndex并重试。

**Raft会时刻保持以下属性，它们共同构成了图3中的Log Matching属性： **

- 如果日志中的两个条目具有相同的索引和任期，那么它们存储的是同一个命令。

- 如果日志中的两个条目具有相同的索引和任期，那么此条目之前的所有条目都是相同的。

证明如下：

1. 第一个属性源于一个事实：Leader在任期中创建的条目，index都是唯一的，而且index永远不会改变
2. 第二个属性由AppendEntries执行的一致性检查保证：当发送AppendEntries RPC时，其中包含了新条目之前条目的索引和任期。Follower在收到请求后会进行检查，如果没有找到相同索引和任期的条目，那么它将拒绝新条目。

总结：日志的初始空状态时，满足Log Matching，增加日志时，一致性检查会检查Log Matching属性。因此，每当 AppendEntries 返回成功时，Leader就知道Follower的日志与自己的日志完全一致。

### 日志修复

正常情况下，Leader和Follower的日志一致，所以能通过一致性检查。然而，Leader的崩溃会使日志不一致（老Leader还没有完成日志同步就崩溃了）。这些不一致会在多次崩溃中加剧。图7给出了一些案例。Follower可能会丢失Leader的条目，可能会有Leader没有的额外条目，或者两者都有。日志中缺失和多余的条目可能跨越多个任期。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425175616580.png" alt="image-20230425175616580" style="zoom:50%;" align="center"/>

<div align = "center"><font color = "green">图7：当顶部的Leader当权时，跟随者日志中可能出现(a–f)中的任何一种情况。每个方框代表一个日志条目；方框中的数字是其任期。跟随者可能会缺少条目（a–b），可能有额外的未提交条目（c–d），或者两者兼有（e–f）。例如，情况（f）可能发生在服务器成为第2个任期的Leader后，向其日志中添加了几个条目，然后在提交它们之前崩溃；它很快重新启动，成为第3个任期的Leader，并向其日志中添加了几个更多的条目；在第2个任期或第3个任期的任何条目被提交之前，该服务器再次崩溃，并持续停机了几个任期。</font></div>

在Raft中，Leader会强制Follower的日志与自己的日志保持一致。Follower日志中的冲突条目将会被Leader日志覆盖。第5.4节将进行说明：在加上另一个限制条件时，这个做法是安全的。

同步日志步骤：

1. 找到最后一条共有的日志条目，Follower删除之后所有的条目

2. 向Follower发送之后的所有日志条目。

   所有这些操作都是响应于AppendEntries RPC执行的一致性检查。Leader为每个Follower维护一个nextIndex，即Leader将要发送给follower的下一个日志条目的索引。

   Leader第一次当选时，

   1. 将所有Follower的nextIndex值（自己维护的）初始化为最后一个条目之后的索引（图7中的位置11）
   2. 如果主从日志不一致，则在下一个AppendEntries RPC中，一致性检查将失败。
   3. 之后，Leader会减少nextIndex并重试AppendEntries RPC。
   4. 最终，nextIndex将减少到Leader和Follower日志中最大匹配的位置点。此时AppendEntries成功。

3. 之后删除Follower日志中所有的冲突条目，并将Leader日志发送过去（如果有的话）。

因此，一旦AppendEntries成功，Follower的日志就会与Leader的日志一致，并将在任期内始终保持一致。

通过这种机制，Leader在掌权时不需要采取任何特殊措施来恢复日志一致性。只需正常操作，日志会在AppendEntries一致性检查失败的情况下自动修复。Leader永远不需要覆盖或删除自己日志中的条目（图3中的Leader仅附加属性）。

上述日志复制机制展现了第2节中描述的理想的共识属性：只要大多数服务器正常运行，Raft就可以接受、复制和应用新的日志条目；在正常情况下，一个新的条目可以通过向大多数集群进行一轮RPC复制；单个缓慢的Follower不会影响性能。

## 5.4 Safety

之前的章节描述了Raft的选举过程和复制日志过程。然而，到目前为止描述的机制还不足以确保状态的一致。

例如，当Leader提交了多个日志条目时，一个跟随者可能不可用，然后被选为Leader，并用新的日志条目覆盖这些条目；结果，状态出错。本节将添加一些限制，完善Raft算法

1. 限制选举资格。Leader必须包含之前所有已提交的日志条目（从图3中的“Leader完备性”可知）。
2. 明确提交规则。

最后，我们提供“Leader完备性”的证明草图，展示它是如何确保状态机的正确性的。

### 5.4.1 选举限制

对于Raft，日志条目只从Leader流向Follower，Leader永远不会覆盖其日志中的现有条目。

Raft在投票阶段就添加了限制，防止未包含所有已提交条目的候选者赢得选举：

1. RequestVote RPC中包含有关候选者日志的信息，当收到投票请求时，接收方会将日志信息和自己本地的日志进行对比
2. 如果对方的日志比自己的新，那就投票给他，反之拒绝投票

日志“新”的定义：比较日志的最后一个条目，先比较任期，再比较索引。

### 5.4.2 提交之前任期的条目

如5.3节所述，当一个条目已存储到大多数服务器上时，就可以说该条目已提交。如果Leader在提交一项条目之前崩溃，未来的Leader将尝试完成该条目的复制。然而，一个来自以前任期的，已被存储在大多数服务器上的条目，Leader仍不能认为该条目已被提交。图8说明了这种情况，旧的日志条目存储在大多数服务器上，但仍然被未来的Leader覆盖。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230427152026231.png" alt="image-20230427152026231" style="zoom:50%;" align="left"/>

> 图8：一个时间序列显示了为什么Leader不能使用较早任期的日志条目来确定提交。在（a）中，S1是Leader，并部分复制了2号条目。在(b)中，S1崩溃了；S5凭借S3、S4和自己的投票当选为第三任期的Leader，并接受了日志索引2的不同条目。在（c）中，S5崩溃了；S1重新启动，被选为Leader，并继续复制。此时，第2项的日志条目已经在大多数服务器上复制，但它没有被提交。如果S1像(d)那样崩溃，S5可以被选为Leader（有S2、S3和S4的投票），并用它自己的第3学期的条目覆盖该条目。然而，如果S1在崩溃前在大多数服务器上复制了其当前任期的条目，如(e)，那么这个条目就被提交了（S5不能赢得选举）。此时，前面的条目都会被提交。

为了消除类似图8中的问题，Raft不会使用计数副本规则提交来自以前任期的日志条目。只有Leader当前任期的日志条目通过计数副本规则来提交；一旦这样提交了当前任期的一项条目，因为**Log Matching Property**性质，那么就可以认为所有先前的条目都间接地提交了。

>Log Matching Property：
>
>如果两个日志在某个索引处具有相同的任期和索引，那么在该索引之前的所有条目会是相同的，不会存在差异。

### 5.4.3 安全性证明

Leader Completeness：如果一个日志条目已被提交，那么这个条目将会出现在所有后续任期的领导者日志中。
