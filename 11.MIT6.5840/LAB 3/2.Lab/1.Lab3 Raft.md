# Lab3 Raft

## 1.Getting Started

代码位置：

- 基础框架代码位置：src/raft/raft.go

- 测试代码：src/raft/test_test.go

建议测试时使用`-race`

## 2.The code

1. 向`raft/raft.go`添加代码来实现Raft。

2. 实现必须支持以下接口

   ```go
   // 创建一个Raft Server
   rf := Make(peers, me, persister, applyCh)
   func Make(peers []*labrpc.ClientEnd, 
             me int,
             persister *Persister, 
             applyCh chan ApplyMsg);
   
   // start agreement on a new log entry:
   rf.Start(command interface{}) (index, term, isleader)
   
   // ask a Raft for its current term, and whether it thinks it is leader
   rf.GetState() (term, isLeader)
   
   // each time a new entry is committed to the log
   // each Raft peer should send an ApplyMsg to the 
   // service (or tester)
   type ApplyMsg
   ```

   通过调用`Make(peers,me,…)`来创建Raft peer。

   - `peers`：Raft所有Server的网络标识符(比如IP地址)，包括该peer本身，用于RPC。
   - `me`：该peer在peers数组中的下标。

   `Start(command)`：要求Raft开始处理、将命令追加到复制日志。`Start()`应立即返回，无需等待日志追加完成。

   service期望您的实现将每个新提交的日志条目的`ApplyMsg`发送到`Make()`的`applyCh`channel参数。？？

3. `raft.go`包含发送RPC(`sendRequestVote()`)和处理传入RPC(`RequestVote()`)的示例代码。您的Raft peer应使用labrpc Go包(位于`src/labrpc`)交换RPC。测试组件可以告诉`labrpc`延迟某个RPC、重新排序并丢弃它们以模拟各种网络故障。你可以临时修改`labrpc`，但请确保你的Raft与原始`labrpc`兼容，因为需要使用它来测试和评分。您的Raft实例必须仅与RPC交互；例如，它们不允许使用共享变量或文件进行通信

4. 后续实验都以该实验为基础，编写可靠的代码非常重要。

## Part 3A: leader election ([moderate](https://pdos.csail.mit.edu/6.824/labs/guidance.html))

> Task:
>
> 实现Raft的Leader选举和心跳(没有日志条目的AppendEntries RPC)机制。本节的目标是选举出Leader，如果Leader没有失效，其将保持Leader状态；如果旧Leader失效或旧Leader的消息丢失，则选出新Leader接管。
>
> 运行 `go test -run 3A` 来测试你的代码。

提示：

- 直接运行你的Raft实现会有些困难；你可以通过测试器来运行它，即`go test -run 3A`。
- 遵循论文中的图2。本节你只需关注发送和接收`RequestVote RPC`、Leader选举规则，以及选举相关的State属性。
- 将图2中的Leader选举状态添加到`raft.go`的Raft结构体中。还需要定义一个结构体存储每个日志条目的信息。
- 填写`RequestVoteArgs`和`RequestVoteReply`结构体。修改`Make()`函数以创建一个后台goroutine，该goroutine会定期启动领导者选举，通过发送 `RequestVote`RPC来实现，尤其是在一段时间没有收到其他节点的响应时。实现 `RequestVote()`RPC处理器，以便服务器之间能够投票。
- 为实现心跳，定义一个`AppendEntries RPC` 结构体(暂时不需要所有的参数)，并使Leader定期发送RPC。编写一个`AppendEntries RPC`处理方法。
- 测试器要求Leader每秒发送心跳RPC的次数不超过十次。
- 测试器要求你的Raft在旧领导者失败后(如果多数节点仍能通信),五秒内选举出新的领导者。
- 论文的第5.2节提到选举超时范围为150到300ms。由于测试器限制每秒最多发送十次心跳，因此你需要使用比150到300毫秒更大的选举超时时间，但又不能太大，以免在五秒内无法选出Leader。
- 你可能会发现Go的`rand`很有用。
- 你需要编写周期性或延迟时间后执行的代码。最简单的方法是创建一个 goroutine，并在循环中调用`time.Sleep()`；请参见`Make()`为此目的创建的 `ticker()` goroutine。不要使用Go的`time.Timer`或`time.Ticker`，因为它们很难正确使用。
- 如果你的代码无法通过测试，请重新阅读论文中的图2；Leader选举的完整逻辑分布在图的多个部分。
- 不要忘记实现`GetState()`。
- 测试器在关闭一个实例时会调用`rf.Kill()`。你可以通过`rf.killed()`检查 `Kill()`是否已被调用。你可能需要在所有循环中进行检查，以避免死掉的Raft实例打印出混乱的消息。
- Go RPC只发送字段名以大写字母开头的结构体字段。子结构体的字段名也必须以大写字母开头(例如，数组中的日志记录字段)。`labgob`包会警告你这点；不要忽视这些警告。
- 本实验中最具挑战性的部分可能是调试。记得让你的实现易于调试。

如果实现正确，你的测试结果会和下图类似

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240829014055963.png" alt="image-20240829014055963" style="zoom:50%;" />

每行`Passed`包含五个数字：分别是

- 测试花费的时间(秒)
- Raft节点数量
- 测试期间发送的RPC数量
- RPC消息的总字节数
- Raft报告已提交的日志条目数量

你可以忽略这些数字，但它们会有助于你检查实现中发送的RPC数量。在后续Lab中，如果测试`go test`总花费超过600秒，或任何单个测试超过120秒，会判定失败。

## Part 3B: log ([hard](https://pdos.csail.mit.edu/6.824/labs/guidance.html))

> Task
>
> 完成Leader和Follower代码，实现Append New Log Entries的功能，通过`go test -run 3B`的测试。

提示：

- 第一个目标是通过`TestBasicAgree3B()`测试。首先实现`Start()`，然后编写代码通过`AppendEntries RPC`发送和接收新的日志条目，如图2所示。在每个对等点上的`applyCh`上发送每个新提交的条目。
- 您将需要实现选举限制（论文中第5.4.1节）。
- 您的代码中可能存在反复检查某些事件的循环。不要让这些循环不停地执行，这会减慢代码速度，导致测试失败。使用Go的[条件变量](https://golang.org/pkg/sync/#Cond)，或在每个循环迭代中插入`time.Sleep(10 * time.Millisecond)`。
- 为方便之后的Lab，编写干净清晰的代码。如需参考，请重新访问我们的[指导页面](https://pdos.csail.mit.edu/6.824/labs/guidance.html)，其中包含开发和调试代码的建议。
- 如果测试失败，请查看`test_test.go`和`config.go`了解正在测试的内容。`config.go`还说明了`测试`如何使用Raft API。

如果代码运行速度太慢，测试可能会失败，可以使用time命令检查代码使用了多少实际时间和CPU时间。以下是典型的输出：

```shell
$ time go test -run 3B
Test (3B): basic agreement ...
  ... Passed --   0.9  3   16    4572    3
Test (3B): RPC byte count ...
  ... Passed --   1.7  3   48  114536   11
Test (3B): agreement after follower reconnects ...
  ... Passed --   3.6  3   78   22131    7
Test (3B): no agreement if too many followers disconnect ...
  ... Passed --   3.8  5  172   40935    3
Test (3B): concurrent Start()s ...
  ... Passed --   1.1  3   24    7379    6
Test (3B): rejoin of partitioned leader ...
  ... Passed --   5.1  3  152   37021    4
Test (3B): leader backs up quickly over incorrect follower logs ...
  ... Passed --  17.2  5 2080 1587388  102
Test (3B): RPC counts aren't too high ...
  ... Passed --   2.2  3   60   20119   12
PASS
ok  	6.5840/raft	35.557s

real	0m35.899s
user	0m2.556s
sys	0m1.458s
$
```

- `ok 6.5840/raft 35.557s`表示3B测试所用时间为35.557秒的实际时间。
- `user 0m2.556s`表示代码消耗了2.556秒的CPU时间，即实际执行指令（而不是等待或休眠）所用的时间。
- 如果你的代码在3B测试中使用的实际时间远超一分钟，或者CPU时间远超5秒，您以后可能会遇到麻烦。寻找以下情况：花费时间在休眠或等待RPC超时，循环在没有休眠或等待条件或通道消息的情况下运行，或者发送大量RPC。

## Part 3C: persistence ([hard](https://pdos.csail.mit.edu/6.824/labs/guidance.html))

## Part 3D: log compaction ([hard](https://pdos.csail.mit.edu/6.824/labs/guidance.html))

