# Lab3 Raft

## 1.Getting Started

代码位置：

- 基础框架代码位置：src/raft/raft.go

- 测试代码：src/raft/test_test.go

建议测试时使用`-race`

## 2.The code

1. 向`raft/raft.go`添加代码来实现Raft。

2. 实现必须支持以下接口

   ```go
   // 创建一个Raft Server
   rf := Make(peers, me, persister, applyCh)
   func Make(peers []*labrpc.ClientEnd, 
             me int,
             persister *Persister, 
             applyCh chan ApplyMsg);
   
   // start agreement on a new log entry:
   rf.Start(command interface{}) (index, term, isleader)
   
   // ask a Raft for its current term, and whether it thinks it is leader
   rf.GetState() (term, isLeader)
   
   // each time a new entry is committed to the log
   // each Raft peer should send an ApplyMsg to the 
   // service (or tester)
   type ApplyMsg
   ```

   通过调用`Make(peers,me,…)`来创建Raft peer。

   - `peers`：Raft所有Server的网络标识符(比如IP地址)，包括该peer本身，用于RPC。
   - `me`：该peer在peers数组中的下标。

   `Start(command)`：要求Raft开始处理、将命令追加到复制日志。`Start()`应立即返回，无需等待日志追加完成。

   service期望您的实现将每个新提交的日志条目的`ApplyMsg`发送到`Make()`的`applyCh`channel参数。？？

3. `raft.go`包含发送RPC(`sendRequestVote()`)和处理传入RPC(`RequestVote()`)的示例代码。您的Raft peer应使用labrpc Go包(位于`src/labrpc`)交换RPC。测试组件可以告诉`labrpc`延迟某个RPC、重新排序并丢弃它们以模拟各种网络故障。你可以临时修改`labrpc`，但请确保你的Raft与原始`labrpc`兼容，因为需要使用它来测试和评分。您的Raft实例必须仅与RPC交互；例如，它们不允许使用共享变量或文件进行通信

4. 后续实验都以该实验为基础，编写可靠的代码非常重要。

## Part 3A: leader election ([moderate](https://pdos.csail.mit.edu/6.824/labs/guidance.html))

> Task:
>
> 实现Raft的Leader选举和心跳(没有日志条目的AppendEntries RPC)机制。本节的目标是选举出Leader，如果Leader没有失效，其将保持Leader状态；如果旧Leader失效或旧Leader的消息丢失，则选出新Leader接管。
>
> 运行 `go test -run 3A` 来测试你的代码。

提示：

- 直接运行你的Raft实现会有些困难；你可以通过测试器来运行它，即`go test -run 3A`。
- 遵循论文中的图2。本节你只需关注发送和接收`RequestVote RPC`、Leader选举规则，以及选举相关的State属性。
- 将图2中的Leader选举状态添加到`raft.go`的Raft结构体中。还需要定义一个结构体存储每个日志条目的信息。
- 填写`RequestVoteArgs`和`RequestVoteReply`结构体。修改`Make()`函数以创建一个后台goroutine，该goroutine会定期启动领导者选举，通过发送 `RequestVote`RPC来实现，尤其是在一段时间没有收到其他节点的响应时。实现 `RequestVote()`RPC处理器，以便服务器之间能够投票。
- 为实现心跳，定义一个`AppendEntries RPC` 结构体(暂时不需要所有的参数)，并使Leader定期发送RPC。编写一个`AppendEntries RPC`处理方法。
- 测试器要求Leader每秒发送心跳RPC的次数不超过十次。
- 测试器要求你的Raft在旧领导者失败后(如果多数节点仍能通信),五秒内选举出新的领导者。
- 论文的第5.2节提到选举超时范围为150到300ms。由于测试器限制每秒最多发送十次心跳，因此你需要使用比150到300毫秒更大的选举超时时间，但又不能太大，以免在五秒内无法选出Leader。
- 你可能会发现Go的`rand`很有用。
- 你需要编写周期性或延迟时间后执行的代码。最简单的方法是创建一个 goroutine，并在循环中调用`time.Sleep()`；请参见`Make()`为此目的创建的 `ticker()` goroutine。不要使用Go的`time.Timer`或`time.Ticker`，因为它们很难正确使用。
- 如果你的代码无法通过测试，请重新阅读论文中的图2；Leader选举的完整逻辑分布在图的多个部分。
- 不要忘记实现`GetState()`。
- 测试器在关闭一个实例时会调用`rf.Kill()`。你可以通过`rf.killed()`检查 `Kill()`是否已被调用。你可能需要在所有循环中进行检查，以避免死掉的Raft实例打印出混乱的消息。
- Go RPC只发送字段名以大写字母开头的结构体字段。子结构体的字段名也必须以大写字母开头(例如，数组中的日志记录字段)。`labgob`包会警告你这点；不要忽视这些警告。
- 本实验中最具挑战性的部分可能是调试。记得让你的实现易于调试。

如果实现正确，你的测试结果会和下图类似

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240829014055963.png" alt="image-20240829014055963" style="zoom:50%;" />

每行`Passed`包含五个数字：分别是

- 测试花费的时间(秒)
- Raft节点数量
- 测试期间发送的RPC数量
- RPC消息的总字节数
- Raft报告已提交的日志条目数量

你可以忽略这些数字，但它们会有助于你检查实现中发送的RPC数量。在后续Lab中，如果测试`go test`总花费超过600秒，或任何单个测试超过120秒，会判定失败。

### 思路





## Part 3B: log ([hard](https://pdos.csail.mit.edu/6.824/labs/guidance.html))

## Part 3C: persistence ([hard](https://pdos.csail.mit.edu/6.824/labs/guidance.html))

## Part 3D: log compaction ([hard](https://pdos.csail.mit.edu/6.824/labs/guidance.html))

