# Raft简单总结

### 状态

| 所有server都有的持久化状态           | 先存储，然后响应RPC                                          |
| ------------------------------------ | ------------------------------------------------------------ |
| currentTerm                          | 当前任期，初始为0，单调递增                                  |
| votedFor                             | 当前任期自己投的候选人的`candidateId`，没有就是null          |
| log[]                                | log条目集，每个条目都包含状态机的命令，以及Leader收到条目时的任期，首个条目的index为1 |
| **所有server都有的Volatile state：** |                                                              |
| commitIndex                          | 被提交的最大日志条目的index，初始为0                         |
| lastApplied                          | 被应用到状态机的日志条目的index，初始为0                     |
| **Leader独有的Volatile state:**      |                                                              |
| nextIndex[]                          | 对于每个server，下次要发送的日志条目的起始index，起始为`Leader last log index + 1` |
| matchIndex[]                         | 对于每个server，已复制的最高日志条目的index，初始为0。       |

### AppendEntries RPC，用于追加日志

> 1. 由Leader发起，发送给follower，用于复制日志条目(§5.3)
> 2. 也用于心跳连接(§5.2)

| 参数         |                                                             |
| ------------ | ----------------------------------------------------------- |
| term         | Leader 任期                                                 |
| leaderId     | follower可通过这个重定向其他client的请求到Leader            |
| prevLogIndex | 前一个日志的index                                           |
| prevLogTerm  | 前一个日志的term                                            |
| entries[]    | 日志条目，心跳时为空                                        |
| leaderCommit | leader的commit Index                                        |
| **返回结果** |                                                             |
| term         | 用于Leader的更新                                            |
| success      | 如果follower的日志和prevLogIndex、prevLogTerm匹配就返回true |

**接收方回复**

1. 如果Leader的任期小于follower的任期，返回false

2. 如果follower的`prevLogIndex`、`prevLogTerm`匹配失败，返回false

3. 如果follower的日志和Leader发来的日志冲突（比如相同的index，不同的任期），则删除自己的日志，用Leader发来的替换掉。

4. 只添加没有的日志

5. `If leaderCommit > commitIndex：`

   `set commitIndex = min(leaderCommit, index of last new entry)`

### RequestVote RPC

> 由Candidate发起，收集投票(§5.2).

| 参数         | -                                    |
| ------------ | ------------------------------------ |
| term         | Candidate的当前任期                  |
| candidateId  | 说明谁在请求选票                     |
| lastLogIndex | Candidate最后一个日志项的index(§5.4) |
| lastLogTerm  | Candidate最后一个日志项的任期(§5.4)  |
| **返回结果** |                                      |
| term         | 当前任期                             |
| voteGranted  | 是否投票                             |

**Receiver implementation:**

1. `if term < currentTerm: return false`(§5.1)
2. 如果`votedFor`是null或candidateId，并且候选人与接收人的日志一样是最新的，则投票(§5.2, §5.4)。

### Rules for Servers

**All Servers:**

1. `If commitIndex > lastApplied`: 增加lastApplied，将log应用到状态机(§5.3)
2. 如果RPC的请求或者回复中包含的term大于自身term：则更新自己的term，并将自己转为follower状态(§5.1)

**Followers:**

1. 回应来自候选人和leader的RPC
2. 如果选举超时，没有收到Leader的AppendEntries RPC，本任期也没有投票给Candidate时，转换为候选人

**Candidates:**

1. 转换为候选人状态后，启动选举：
   - 增加当前任期
   - 投票给自己
   - 重置选举超时时间
   - 发送RequestVote RPC给其他所有服务器
2. 如果收到了超过半数的投票，成为Leader
3. 如果RPC被Leader接收到，停止选举，转换回follower
4. 如果选举时超时，再次启动选举

**Leaders:**

1. 当选举完成后：向每个服务器发送初始的空AppendEntries RPC(心跳)；在空闲期间重复发送以防止选举超时。(§5.2)
2. 如果收到来自客户端的指令: 添加指令到本地日志，待条目应用到状态机后再响应(§5.3)
3. If last log index ≥ nextIndex for a follower: 发送 AppendEntries RPC 并附上从nextIndex开始的 log entries 
   - If successful: 更新 nextIndex 和 matchIndex (§5.3)
   - If AppendEntries fails because of log inconsistency: 减小nextIndex并重试(§5.3)
4. 如果存在一个N，使得N>commitIndex，大多数的matchIndex[i]≥N，并且log[N].term == currentTerm：设置commitIndex = N (§5.3, §5.4).

## Part 3A: leader election

### 1.选举主要流程

1. 新服务器加入集群

服务器在启动时状态是Follower。只要持续接收到Leader或Candidate的心跳信息，就继续保持Follower状态。

2. 开始选举

每个Server都有一个随机的选举超时时间，选举超时在一个固定区间内随机选择（例如，150-300毫秒）

如果Follower在`选举超时`时间内未收到有效的心跳信息，就认为当前没有有效Leader，转换自己为Candidate，发起选举。

> 心跳消息：一般是不包含日志条目的`AppendEntries RPC`

3. 投票规则

服务器收到`RequestVote RPC`时，根据以下规则进行投票：

> 服务器以先到先得的方式投票，且每个任期只能投一票。

- 如果收到的RPC的任期小于服务器当前的任期，**拒绝投票**。
- 如果服务器已经为当前任期投过票，或收到的RPC中的日志不如自己的日志新(最后一个条目的任期较旧或者任期相同但是编号较小)，拒绝投票。
- 如果以上情况都不满足，服务器会为Candidate投票，并重置自己的选举超时时间。

4. 选举过程

- 若选举过程中，`Candidate`收到其他Leader的心跳信息，且该Leader的任期**大于等于**候选人的任期，那么Candidate会承认新Leader并转回Follower状态；反之继续进行选举。

4. 选举结果

- 若Candidate获得的选票超过半数(3/5)，则赢得选举，成为新Leader。同时向所有Server发送心跳消息，以防止新的选举。
- 若选举超时，没有选出Leader，即没人获得多数票，一般是因为同时有多个Follower成为了Candidate。这种情况下，Candidate会等待一个随机的`选举超时`时间，增加任期，重新开始新一轮选举。

### 2.各组件逻辑

1. 各组件都要遵守的规则

   任意RPC中包含的term大于自身term，则更新自己的term，并将自己转为follower状态，本节主要是心跳RPC和RequestVote RPC

2. 随机超时检测`ticker()`

   功能：检测是否需要进行选举，使用Goroutine并行运行

   - role == Leader：跳过所有检测

   - role != Leader：

     若未收到心跳消息或未投票给任何人，举行选举

3. 接收到心跳消息

   1. 如果心跳Term<当前Term，拒绝心跳，直接返回

      `心跳TermTerm==当前Term`或`心跳TermTerm>当前Term`，则重置超时检测

   2. 若`role==Candidate`或`role==Leader&&心跳Term>当前Term`

      - 转回Follower

      - 更新当前Term为心跳Term
      - 更新LeaderID为心跳发送方
      - 更新VoteFor为心跳发送方

4. 接收到投票请求

   说明已经有人开始选举，因此重置超时检测器，推迟自身可能要开始的选举

   1. 如果请求投票`RPC Term<当前Term`，拒绝

   2. 如果请求投票`RPC Term>当前Term`，投票

      更新自身Term

      如果当前Role!=Follower,转回Follower

   3. 如果请求投票`RPC Term==当前Term`，且当前Term没有投过票，投票

5. 接收心跳超时，开始选举

   1. 配置自身角色

      1. Role切换为Candidate
      2. 投票给自己
      3. 当前Term+1
      
   2. 向其他Server请求投票
   
      票数过半，当选Leader
   
      1. 切换Role为Leader
      2. 更新LeaderID为自己
      3. 启动心跳发送程序

### 3.结果

测试6K次，全部Pass

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240901184324743.png" alt="image-20240901184324743" style="zoom:30%;" />

代码地址：https://github.com/INnoVationv2/6.5840/tree/Lab-3A-Dev/src/raft

```shell
go test -run 3A -count 1000 -failfast -timeout 3000m -race
```

## Part 3B: log

### 1.Log相关总结
