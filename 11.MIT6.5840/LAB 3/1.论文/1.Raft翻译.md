从第5章开始翻译，之前的略去

## 5.The Raft consensus algorithm

Raft是一种用于管理复制日志的算法，如第2节所述。图2对算法进行了简洁的总结，供参考；图 3 列出了算法的关键属性；这些图中的元素将在本节其余部分逐一讨论。

Raft 通过首先选举出一个显著的领导者来实现共识，然后将管理复制日志的完整责任交给领导者。领导者接受来自客户端的日志条目，将其复制到其他服务器，并告诉服务器何时可以安全地将日志条目应用到其状态机中。拥有一个领导者简化了复制日志的管理。例如，领导者可以决定在日志中放置新条目的位置，而无需咨询其他服务器，数据也以简单的方式从领导者流向其他服务器。领导者可能会失败或与其他服务器断开连接，此时将选举出一个新的领导者。

鉴于领导者的方法，Raft 将共识问题分解为三个相对独立的子问题，这些子问题将在以下小节中讨论。

- 领导者选举：当现有的领导者失败时，必须选举出一个新的领导者（第 5.2 节）。

- 日志复制：领导者必须接受来自客户端的日志条目，并在集群中进行复制，迫使其他日志与其自身的日志保持一致（第 5.3 节）。
- 安全性：Raft 的关键安全属性是图 3 中的状态机安全属性：如果任何服务器已将特定的日志条目应用到其状态机中，则其他任何服务器都不得对相同的日志索引应用不同的命令。第 5.4 节描述了 Raft 如何确保这一属性；这一解决方案涉及对第 5.2 节中描述的选举机制的额外限制。

在介绍了共识算法之后，本节将讨论系统的可用性问题以及时序在系统中的作用。

1. State

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240829002754536.png" alt="image-20240829002754536" style="zoom:50%;" />

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/%E7%8A%B6%E6%80%81.svg" alt="状态" style="zoom:70%;" />

| State                                                    |                                                              |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| 持久化状态在所有服务器上:（在响应RPC之前更新到稳定存储） |                                                              |
| currentTerm                                              | 最新的任期号（在首次启动时初始化为0，并单调递增）            |
| votedFor                                                 | 候选人在当前任期内收到的投票的 candidateId（如果没有则为 null） |
| log[]                                                    | 日志条目；每个条目包含要执行的状态机命令和领导者接收条目的任期（第一个索引是 1） |
| **Volatile state on all servers:**                       |                                                              |
| commitIndex                                              | 已知的最高已提交日志条目的索引（初始化为 0，递增）。         |
| lastApplied                                              | 日志条目应用到状态机上的最高索引（初始化为 0，递增）。       |
| Volatile state on leaders:(Reinitialized after election) |                                                              |
| nextIndex[]                                              | 每个服务器的下一个日志条目的索引（初始化为领导者日志中的最后一个索引 + 1）。 |
| matchIndex[]                                             | 每个服务器的已知最高日志条目的索引（初始化为 0，递增）。     |

| **AppendEntries RPC**                                        |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Invoked by leader to replicate log entries (§5.3); also used as heartbeat (§5.2). |                                                              |
| **Arguments:**                                               |                                                              |
| term                                                         | 领导者的任期（term）                                         |
| leaderId                                                     | 以便跟随者可以将客户端重定向                                 |
| prevLogIndex                                                 | 紧接在新日志条目之前的日志条目的索引                         |
| prevLogTerm                                                  | prevLogIndex 条目的任期。                                    |
| entries[]                                                    | 要存储的日志条目（心跳时为空；为了效率可能会发送多个）。     |
| leaderCommit                                                 | 领导者的commitIndex                                          |
| **Results:**                                                 |                                                              |
| term                                                         | currentTerm，供领导者更新自己。                              |
| success                                                      | 如果跟随者包含与 prevLogIndex 和 prevLogTerm 匹配的条目，则为 true |
| 接收者实现：                                                 |                                                              |
| 1. 如果 `term < currentTerm`，回复 `false` (§5.1)。          |                                                              |
| 2. 如果日志在 `prevLogIndex` 处不包含一个与 `prevLogTerm` 匹配的条目，回复 `false` (§5.3)。 |                                                              |
| 3. 如果现有条目与新条目冲突（相同索引但不同的任期），删除现有条目及其后的所有条目 (§5.3)。 |                                                              |
| 4. 追加日志中尚未存在的新条目。                              |                                                              |
| 5. 如果 `leaderCommit > commitIndex`，将 `commitIndex` 设置为 `min(leaderCommit, index of last new entry)`。 |                                                              |

| **RequestVote RPC**                                          | -                                       |
| ------------------------------------------------------------ | --------------------------------------- |
| Invoked by candidates to gather votes (§5.2).                |                                         |
| term                                                         | 候选人的任期                            |
| candidateId                                                  | 请求投票的候选人                        |
| lastLogIndex                                                 | 候选人最后一个日志条目的索引 (§5.4)     |
| lastLogTerm                                                  | 候选人最后一个日志条目的任期 (§5.4)     |
| **Results:**                                                 | -                                       |
| term                                                         | `currentTerm`：用于候选人更新自身状态； |
| voteGranted                                                  | `true` 表示候选人收到了投票。           |
| **Receiver implementation:**                                 |                                         |
| 1.如果 term < currentTerm，回复 false (§5.1)。               |                                         |
| 2.如果 votedFor 为 null 或 candidateId，并且候选人的日志至少和接收者的日志一样新，则授予投票 (§5.2, §5.4)。​ |                                         |

| **Rules for Servers**                                        | -    |
| ------------------------------------------------------------ | ---- |
| **All Servers:**                                             |      |
| - 如果 `commitIndex > lastApplied`：递增 `lastApplied`，并将 `log[lastApplied]` 应用到状态机（§5.3）。追随者 (§5.2)：<br/><br/>- 响应来自候选人和领导者的 RPCs。<br/>- 如果选举超时时间过去而没有收到当前领导者的 `AppendEntries` RPC 或者没有将选票投给候选人：转换为候选人。<br/><br/>候选人 (§5.2)：<br/><br/>- 转换为候选人时，开始选举：<br/>  - 增加 `currentTerm`。<br/>  - 为自己投票。<br/>  - 重置选举计时器。<br/>  - 向所有其他服务器发送 `RequestVote` RPCs。<br/>  - 如果从大多数服务器收到投票：成为领导者。<br/>  - 如果从新的领导者收到 `AppendEntries` RPC：转换为追随者。<br/>  - 如果选举超时时间过去：开始新的选举。<br/><br/>领导者：<br/><br/>- |      |
| - 如果 RPC 请求或响应包含任期 `T > currentTerm`：将 `currentTerm` 设置为 `T`，并转换为追随者（§5.1）。 |      |
| **Followers (§5.2):**                                        |      |
| - 响应来自候选人和领导者的 RPCs。                            |      |
| - 如果选举超时时间过去而没有收到当前领导者的 `AppendEntries` RPC 或者没有将选票投给候选人：转换为候选人。 |      |
| **Candidates (§5.2):**                                       |      |
| - 转换为候选人时，开始选举：<br/>  - 增加 `currentTerm`。<br/>  - 为自己投票。<br/>  - 重置选举计时器。<br/>  - 向所有其他服务器发送 `RequestVote` RPCs |      |
| 如果从大多数服务器收到投票：成为领导者。                     |      |
| 如果从新的领导者收到 `AppendEntries` RPC：转换为追随者。     |      |
| 如果选举超时时间过去：开始新的选举。                         |      |
| **Leaders:**                                                 |      |
| 当选时：向每个服务器发送初始的空 `AppendEntries` RPCs（心跳）；在空闲期间重复发送以防止选举超时（§5.2）。 |      |
| 如果从客户端收到命令：将条目追加到本地日志，在条目应用到状态机后响应（§5.3）。 |      |
| 如果最后的日志索引 `≥ nextIndex`，则为某个追随者发送从 `nextIndex` 开始的日志条目的 `AppendEntries` RPC。<br/>  - 如果成功：更新该追随者的 `nextIndex` 和 `matchIndex`（§5.3）。<br/>  - 如果 `AppendEntries` 由于日志不一致而失败：递减 `nextIndex` 并重试（§5.3） |      |
| 如果存在一个 `N`，使得 `N > commitIndex`，大多数 `matchIndex[i] ≥ N`，并且 `log[N].term == currentTerm`：设置 `commitIndex = N`（§5.3, §5.4） |      |

> 图2Raft一致性算法的简要总结（不包括成员变更和日志压缩）。左上方框中的服务器行为被描述为一组独立且重复触发的规则。章节编号如§5.2指示了特定功能的讨论位置。更精确的算法描述可以在正式规范[31]中找到。

----------------

>- 选举安全性：
>
>  在给定的任期内最多只能选出一位领导人。§5.2
>
>- 领导人只附加原则：
>
>  领导人从不覆盖或删除其日志中的条目；它只附加新条目。§5.3
>
>- 日志匹配：
>
>  如果两个日志在同一索引和任期内包含相同的条目，那么这些日志在该索引及之前的所有条目中都是相同的。§5.3
>
>- 领导人完整性：
>
>  如果在某一任期内提交了一个日志条目，那么该条目将在所有后续任期的领导人的日志中存在。§5.4
>
>- 状态机安全性：
>
>  如果服务器在给定索引处将日志条目应用于其状态机，则其他服务器永远不会为该索引应用不同的日志条目。§5.4.3
>
>> 图 3：Raft保证这些属性在任何时候都为真。章节编号指示了每个属性的讨论位置。

### 5.1 Raft basics

Raft 集群包含多个服务器；最典型是五台，这允许系统容忍两个故障。在任何给定时刻，每个服务器处于三种状态之一：领导者、跟随者或候选者。在正常操作中，只有一个领导者，所有其他服务器都是跟随者。跟随者是被动的：它们不会主动发起请求，而只是响应领导者和候选者的请求。领导者处理所有客户端请求（如果客户端联系到一个跟随者，跟随者会将其重定向到领导者）。第三种状态，候选者，用于选举新的领导者，如第 5.2 节所述。图 4 显示了这些状态及其转换；这些转换将在下面讨论。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240828225452651.png" alt="image-20240828225452651" style="zoom:40%;" />

> 图4: 服务器状态。跟随者仅响应来自其他服务器的请求。如果一个跟随者没有收到任何通信，它会变成候选者并发起选举。一个获得全体集群多数投票的候选者将成为新的领导者。领导者通常会持续运行，直到出现故障。

Raft将时间分为任意长度的任期，如图5所示。任期用连续的整数编号。每个任期开始时进行一次选举，在选举中一个或多个候选者尝试成为领导者，如第 5.2 节所述。如果候选者赢得选举，它将成为该任期的领导者。在某些情况下，选举可能会导致投票分裂。在这种情况下，任期将结束而没有领导者；一个新任期（带有新的选举）将很快开始。Raft 确保在给定的任期内至多只有一个领导者。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240828225505327.png" alt="image-20240828225505327" style="zoom:40%;" />

> 图5：时间被划分为多个任期，每个任期开始时进行一次选举。选举成功后，一个领导者会管理集群直到该任期结束。一些选举可能会失败，在这种情况下，任期会在没有选择领导者的情况下结束。不同服务器在不同时间可能会观察到任期的转换。

不同的服务器可能在不同时间观察到任期的转换，在某些情况下，服务器可能不会观察到选举或整个任期。任期在 Raft 中充当逻辑时钟 [14]，它们允许服务器检测过时的信息，例如过期的领导者。每个服务器存储一个当前的任期编号，该编号随时间单调增加。当前的任期在服务器之间通信时交换；如果一个服务器的当前任期小于另一个服务器，则将其当前任期更新为较大的值。如果一个候选者或领导者发现其任期过时，它会立即恢复为跟随者状态。如果一个服务器收到具有过期任期编号的请求，它会拒绝该请求。

Raft 服务器使用远程过程调用（RPC）进行通信，基本共识算法只需要两种类型的 RPC。RequestVote RPC 是由候选者在选举期间发起的（第 5.2 节），而 AppendEntries RPC 是由领导者发起的，用于复制日志条目并提供一种心跳机制（第 5.3 节）。第 7 节添加了一种第三种 RPC，用于在服务器之间传输快照。如果服务器在及时的时间内没有收到响应，它会重试 RPC，并且为了最佳性能，它们会并行发出 RPC。

### 5.2 Leader election

Raft 使用心跳机制来触发领导者选举。当服务器启动时，它们开始作为跟随者运行。只要跟随者收到来自领导者或候选者的有效 RPC，它就会保持在跟随者状态。领导者会定期发送心跳（AppendEntries RPCs，但不携带日志条目）到所有跟随者，以维护其权威。如果跟随者在一个称为选举超时的时间段内没有收到任何通信，它就会假设没有有效的领导者，并开始选举以选择一个新的领导者。

要开始选举，跟随者会增加其当前的任期，并转变为候选者状态。然后它为自己投票，并并行地向集群中的其他每个服务器发出 RequestVote RPC。候选者会继续保持在这种状态，直到发生以下三种情况之一：（a）它赢得选举，（b）另一服务器确立为领导者，或（c）经过一段时间没有产生赢家。下面的段落分别讨论了这些结果。

候选者赢得选举的条件是，它在同一任期内获得了全体集群中多数服务器的投票。每个服务器在给定任期内最多只会为一个候选者投票，按照先到先得的原则（注：第 5.4 节对投票有额外的限制）。多数规则确保在特定任期内最多只有一个候选者可以赢得选举（图 3 中的选举安全属性）。一旦候选者赢得选举，它就成为领导者。然后，它会向所有其他服务器发送心跳消息，以建立其权威并防止新的选举发生。

在等待投票时，候选者可能会收到来自其他服务器的 AppendEntries RPC，声称自己是领导者。如果领导者的任期（包含在 RPC 中）至少和候选者的当前任期一样大，那么候选者会将领导者视为合法，并返回到跟随者状态。如果 RPC 中的任期小于候选者的当前任期，则候选者会拒绝 RPC，并继续保持在候选者状态。

第三种可能的结果是候选者既没有赢得选举也没有失败：如果许多跟随者同时成为候选者，投票可能会分裂，以至于没有候选者获得多数。在这种情况下，每个候选者会超时并通过增加其任期和发起另一轮 RequestVote RPC 来开始新的选举。然而，如果没有额外的措施，投票分裂可能会无限期地重复。

Raft 使用随机的选举超时来确保投票分裂是少见的，并且能够迅速解决。为了防止投票分裂，选举超时从一个固定的时间间隔中随机选择（例如，150-300 毫秒）。这样可以使服务器之间的超时分布更加均匀，在大多数情况下，只有一个服务器会超时；它会赢得选举并在其他服务器超时之前发送心跳消息。相同的机制也用于处理投票分裂。每个候选者在选举开始时重新启动其随机选举超时，并在超时结束前等待，然后再开始下一次选举；这降低了在新选举中再次发生投票分裂的可能性。第 9.3 节显示了这种方法可以快速选举出领导者。

选举是我们在设计选择中如何受到可理解性指导的一个例子。最初我们计划使用排名系统：每个候选者被分配一个唯一的排名，用于在竞争候选者之间进行选择。如果一个候选者发现另一个具有更高排名的候选者，它会返回到跟随者状态，以便更高排名的候选者能更容易地赢得下一次选举。我们发现这种方法在可用性方面产生了微妙的问题（一个排名较低的服务器可能需要超时并重新成为候选者，如果一个排名较高的服务器失败，但如果它做得太早，可能会重置选举领导者的进展）。我们对算法进行了多次调整，但每次调整后都会出现新的边界情况。最终，我们得出结论，随机重试的方法更加明显和易于理解。

### 5.3 Log replication

一旦选举出领导者，它就开始处理客户端请求。每个客户端请求包含一个由复制状态机执行的命令。领导者将命令作为新条目追加到其日志中，然后并行地向其他所有服务器发出 AppendEntries RPC，以复制该条目。当条目被安全地复制后（如下所述），领导者将条目应用到其状态机，并将执行结果返回给客户端。如果跟随者崩溃或运行缓慢，或者网络数据包丢失，领导者会无限期地重试 AppendEntries RPC（即使在响应客户端之后），直到所有跟随者最终存储所有日志条目。

日志的组织如图 6 所示。每个日志条目存储一个状态机命令以及条目被领导者接收到时的任期编号。日志条目中的任期编号用于检测日志之间的不一致，并确保图 3 中的一些属性。每个日志条目还具有一个整数索引，用于标识其在日志中的位置。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240828225716008.png" alt="image-20240828225716008" style="zoom:50%;" />

> 图6：日志由条目组成，这些条目按顺序编号。每个条目包含其创建时的任期（每个框中的数字）和状态机的命令。如果一个条目被认为是安全的，可以将其应用到状态机上，则该条目被视为已提交。

领导者决定何时可以安全地将日志条目应用到状态机中；这样的条目称为已提交。Raft 保证已提交的条目是持久的，并且最终会被所有可用的状态机执行。一个日志条目在创建该条目的领导者已在多数服务器上复制它之后就被认为是已提交的（例如，图 6 中的条目 7）。这也会提交领导者日志中所有之前的条目，包括之前领导者创建的条目。第 5.4 节讨论了在领导者更换后应用此规则的一些细微之处，并且还表明这种提交定义是安全的。领导者跟踪它知道的最高已提交索引，并在未来的 AppendEntries RPC（包括心跳）中包含该索引，以便其他服务器最终得知。一旦跟随者了解到一个日志条目已提交，它会将该条目应用到其本地状态机中（按日志顺序）。

我们设计了 Raft 日志机制，以在不同服务器上的日志之间保持高水平的一致性。这不仅简化了系统的行为，使其更加可预测，而且是确保安全的重要组成部分。Raft 维护以下属性，这些属性共同构成了图 3 中的日志匹配属性：

• 如果两个不同日志中的条目具有相同的索引和任期，则它们存储相同的命令。
• 如果两个不同日志中的条目具有相同的索引和任期，则日志中的所有前面的条目都是相同的。

第一个属性源于领导者在给定任期内最多只创建一个具有给定日志索引的条目，并且日志条目在日志中的位置不会改变。第二个属性通过 AppendEntries 执行的简单一致性检查来保证。在发送 AppendEntries RPC 时，领导者包括其日志中紧跟在新条目前的条目的索引和任期。如果跟随者在其日志中找不到具有相同索引和任期的条目，它将拒绝新的条目。一致性检查作为归纳步骤：日志的初始空状态满足日志匹配属性，一致性检查在扩展日志时保持日志匹配属性。因此，每当 AppendEntries 成功返回时，领导者知道跟随者的日志在新的条目之前与自己的日志完全相同。

在正常操作期间，领导者和跟随者的日志保持一致，因此 AppendEntries 一致性检查不会失败。然而，领导者崩溃可能会导致日志不一致（旧领导者可能没有完全复制其日志中的所有条目）。这些不一致可能会在一系列领导者和跟随者崩溃中累积。图 7 说明了跟随者的日志与新领导者的日志可能不同的方式。跟随者可能缺少在领导者上存在的条目，可能有领导者上不存在的额外条目，或者两者都有。日志中的缺失和额外条目可能跨越多个任期。

在 Raft 中，领导者通过强制将跟随者的日志与自己的日志保持一致来处理不一致。这意味着跟随者日志中的冲突条目将被领导者日志中的条目覆盖。第 5.4 节将展示这种方法在加上一个额外限制时是安全的。

为了使跟随者的日志与领导者的日志保持一致，领导者必须找到两个日志中最新的一致条目，删除跟随者日志中该点之后的所有条目，然后将领导者日志中该点之后的所有条目发送给跟随者。所有这些操作都是响应 AppendEntries RPC 执行的一致性检查。领导者为每个跟随者维护一个 nextIndex，它是领导者将要发送给该跟随者的下一个日志条目的索引。当领导者首次上台时，它将所有 nextIndex 值初始化为其日志中最后一个条目之后的索引（图 7 中的 11）。如果跟随者的日志与领导者的不一致，AppendEntries 一致性检查将在下一次 AppendEntries RPC 中失败。拒绝后，领导者会减少 nextIndex 并重试 AppendEntries RPC。最终，nextIndex 会达到一个点，在该点领导者和跟随者的日志匹配。当发生这种情况时，AppendEntries 将成功，这会删除跟随者日志中的任何冲突条目，并追加来自领导者日志的条目（如果有）。一旦 AppendEntries 成功，跟随者的日志将与领导者的日志一致，并且在该任期内将保持一致。

> 如果需要，可以优化协议以减少被拒绝的 AppendEntries RPC 的数量。例如，在拒绝 AppendEntries 请求时，跟随者可以包括冲突条目的任期和该任期中它存储的第一个索引。通过这些信息，领导者可以减少 nextIndex，以绕过该任期中的所有冲突条目；这样，每个包含冲突条目的任期只需要一个 AppendEntries RPC，而不是每个条目一个 RPC。在实际操作中，我们怀疑这种优化是否必要，因为故障发生的频率较低，不太可能出现许多不一致的条目。

通过这种机制，领导者在上台时无需采取任何特殊措施来恢复日志一致性。它只是开始正常操作，日志会自动收敛以响应 AppendEntries 一致性检查的失败。领导者永远不会覆盖或删除其日志中的条目（图 3 中的领导者仅追加属性）。

这种日志复制机制展示了第 2 节中描述的期望共识属性：只要大多数服务器正常运行，Raft 就可以接受、复制和应用新的日志条目；在正常情况下，一个新条目可以通过一次 RPC 往返复制到集群的大多数服务器；单个慢跟随者不会影响性能。

### 5.4 Safety

前面的章节描述了 Raft 如何选举领导者和复制日志条目。然而，到目前为止描述的机制并不足以确保每个状态机以相同的顺序执行完全相同的命令。例如，跟随者可能在领导者提交多个日志条目时不可用，然后它可能被选为领导者，并用新条目覆盖这些条目；结果，可能会出现不同的状态机执行不同的命令序列。

本节通过添加一个关于哪些服务器可以被选为领导者的限制来完成 Raft 算法。该限制确保任何给定任期的领导者包含所有在之前任期中已提交的条目（图 3 中的领导者完整性属性）。在给定选举限制的情况下，我们将使提交规则更加精确。最后，我们提供了领导者完整性属性的证明概要，并展示它如何导致复制状态机的正确行为。

#### 5.4.1 Election restriction

在任何基于领导者的共识算法中，领导者必须最终存储所有已提交的日志条目。在一些共识算法中，例如 Viewstamped Replication [22]，即使领导者最初不包含所有已提交的条目，也可以选举出领导者。这些算法包含额外的机制来识别缺失的条目，并在选举过程中或之后将它们传输给新领导者。不幸的是，这会导致额外的机制和复杂性。Raft 采用一种更简单的方法，确保每个新领导者在选举时就包含所有来自之前任期的已提交条目，而无需将这些条目传输给领导者。这意味着日志条目只在一个方向流动，从领导者到跟随者，领导者永远不会覆盖其日志中的现有条目。

Raft 使用投票过程来防止候选者赢得选举，除非其日志包含所有已提交的条目。候选者必须联系集群中的大多数服务器才能被选举，这意味着每个已提交的条目必须存在于这些服务器中的至少一个。如果候选者的日志至少与这些服务器中的任何其他日志一样更新（“更新”定义将在下文中详细说明），那么它将包含所有已提交的条目。RequestVote RPC 实现了这一限制：RPC 包含有关候选者日志的信息，如果投票者的日志比候选者的日志更更新，则拒绝投票。

Raft 通过比较日志中最后条目的索引和任期来确定两个日志哪个更更新。如果日志的最后条目具有不同的任期，则具有较晚任期的日志更更新。如果日志以相同的任期结束，则较长的日志更更新。

#### 5.4.2 Committing entries from previous terms

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240828230419880.png" alt="image-20240828230419880" style="zoom:40%;" />

> 图8：时间序列显示了为什么领导者不能使用旧任期的日志条目来确定提交情况。在 (a) 中，S1 是领导者，并部分复制了索引为 2 的日志条目。在 (b) 中，S1 崩溃；S5 被选为任期 3 的领导者，获得了来自 S3、S4 和自身的投票，并接受了索引为 2 的不同条目。在 (c) 中，S5 崩溃；S1 重新启动，成为领导者并继续复制。此时，任期 2 的日志条目已经在大多数服务器上复制，但尚未提交。如果 S1 如 (d) 所示崩溃，S5 可能会被选为领导者（获得来自 S2、S3 和 S4 的投票），并用其任期 3 的条目覆盖该条目。然而，如果 S1 在崩溃之前，如 (e) 所示，将其当前任期的条目复制到大多数服务器上，则该条目被提交（S5 无法赢得选举）。此时，日志中的所有前置条目也都被提交。

正如第 5.3 节所述，领导者知道当一个条目在大多数服务器上存储时，该条目已被提交。如果领导者在提交条目之前崩溃，未来的领导者将尝试完成条目的复制。然而，领导者无法立即得出结论，认为一个来自旧任期的条目在存储在大多数服务器上后就已被提交。图 8 说明了一个旧日志条目虽然存储在大多数服务器上，但仍然可能被未来的领导者覆盖的情况。

为了消除像图 8 中的问题，Raft 从不通过计数副本来提交来自旧任期的日志条目。只有来自领导者当前任期的日志条目才通过计数副本来提交；一旦当前任期的条目以这种方式提交，那么所有之前的条目也会间接提交，因为日志匹配属性的存在。虽然在某些情况下，领导者可以安全地得出一个旧日志条目已提交的结论（例如，如果该条目在每个服务器上都有存储），但 Raft 采取了更保守的方法以保持简单性。

Raft 在提交规则中增加了这种复杂性，因为日志条目在领导者复制来自旧任期的条目时保留了其原始的任期号。在其他共识算法中，如果新的领导者重新复制来自之前“任期”的条目，它必须用新的“任期号”进行复制。Raft 的方法使得处理日志条目更容易，因为条目在时间和日志之间保持相同的任期号。此外，Raft 中的新领导者发送的来自旧任期的日志条目比其他算法中的要少（其他算法必须发送冗余日志条目以重新编号它们，然后才能被提交）。

#### 5.4.3 Safety argument

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240828230509372.png" alt="image-20240828230509372" style="zoom:40%;" />

> 图9：如果 S1（任期 T 的领导者）提交了来自其任期的新日志条目，并且 S5 被选为较晚的任期 U 的领导者，那么必须至少有一台服务器（S3）既接受了该日志条目，又投票支持了 S5。

给定完整的 Raft 算法，我们现在可以更精确地论证领导者完整性属性（Leader Completeness Property）的成立（这一论证基于安全性证明；参见第 9.2 节）。我们假设领导者完整性属性不成立，然后证明一个矛盾。假设任期 T 的领导者（leaderT）提交了来自其任期的日志条目，但该日志条目没有被未来某任期的领导者（leaderU）存储。考虑最小的任期 U > T，其中领导者（leaderU）没有存储该条目。

1. 提交的条目在任期 U 的领导者领导其任期时必须在其日志中缺失（领导者从不删除或覆盖条目）。

2. leaderT 在集群的大多数服务器上复制了该条目，并且 leaderU 从集群的大多数服务器那里获得了选票。因此，至少有一台服务器（“投票者”）既接受了来自 leaderT 的条目，又投票支持了 leaderU，如图 9 所示。投票者是达到矛盾的关键。

3. 投票者必须在投票支持 leaderU 之前接受了来自 leaderT 的提交条目；否则它将拒绝来自 leaderT 的 AppendEntries 请求（它的当前任期会高于 T）。

4. 投票者在投票支持 leaderU 时仍然存储了该条目，因为每个中间的领导者都包含了该条目（根据假设），领导者不会删除条目，跟随者只有在条目与领导者冲突时才删除条目。

5. 投票者将选票授予了 leaderU，因此 leaderU 的日志必须与投票者的日志一样更新。这导致两个矛盾之一。

6. 首先，如果投票者和 leaderU 共享相同的最后日志任期，那么 leaderU 的日志长度必须至少与投票者的日志一样长，因此其日志包含了投票者日志中的每个条目。这是一个矛盾，因为投票者包含了提交的条目，而 leaderU 被假设没有。

7. 否则，leaderU 的最后日志任期必须比投票者的日志任期大。此外，它必须大于 T，因为投票者的最后日志任期至少是 T（它包含了来自任期 T 的提交条目）。创建 leaderU 最后日志条目的早期领导者必须在其日志中包含提交的条目（根据假设）。然后，根据日志匹配属性，leaderU 的日志也必须包含提交的条目，这是一个矛盾。

8. 这完成了矛盾的证明。因此，所有大于 T 的任期的领导者必须包含任期 T 中提交的所有条目。

9. 日志匹配属性保证了未来的领导者也将间接包含已提交的条目，如图 8(d) 中的索引 2。

>鉴于领导者完整性属性（Leader Completeness Property），我们可以证明状态机安全属性（State Machine Safety Property），即图 3 所述：如果某个服务器已将某个索引的日志条目应用于其状态机，则没有其他服务器会在相同索引上应用不同的日志条目。当服务器将日志条目应用于其状态机时，其日志必须与领导者的日志在该条目之前完全一致，并且该条目必须已提交。现在考虑任何服务器应用给定日志索引的最低任期；日志完整性属性（Log Completeness Property）保证所有较高任期的领导者都会存储该相同的日志条目，因此在较高任期中应用该索引的服务器将应用相同的值。因此，状态机安全属性成立。
>
>最后，Raft 要求服务器按照日志索引的顺序应用条目。结合状态机安全属性，这意味着所有服务器将以相同的顺序将完全相同的日志条目应用于其状态机。⬤

### 5.5 Follower and candidate crashes

到目前为止，我们关注了领导者失败的问题。跟随者和候选者崩溃要处理起来简单得多，并且它们的处理方式是相同的。如果跟随者或候选者崩溃，未来发送给它们的 RequestVote 和 AppendEntries RPC 将会失败。Raft 通过无限重试来处理这些失败；如果崩溃的服务器重新启动，则 RPC 将成功完成。如果一个服务器在完成 RPC 后但在回应之前崩溃，它将在重新启动后再次接收到相同的 RPC。Raft 的 RPC 是幂等的，因此这不会造成任何问题。例如，如果一个跟随者接收到一个包含其日志中已存在的日志条目的 AppendEntries 请求，它会忽略这些条目。

### 5.6 Timing and availability

Raft 的一个要求是安全性必须不依赖于时间：系统不能仅仅因为某个事件比预期发生得更快或更慢而产生不正确的结果。然而，可用性（系统及时响应客户端的能力）不可避免地会依赖于时间。例如，如果消息交换比服务器崩溃的典型时间要长，候选者将不会保持足够长的时间来赢得选举；没有稳定的领导者，Raft 就无法取得进展。

领导者选举是 Raft 中对时间最为敏感的方面。只要系统满足以下时间要求，Raft 就能够选举和维持一个稳定的领导者：

$$ \text{broadcastTime} \ll \text{electionTimeout} \ll \text{MTBF} $$

在这个不等式中，broadcastTime 是服务器并行发送 RPC 到集群中的每台服务器并接收响应的平均时间；electionTimeout 是第 5.2 节中描述的选举超时；MTBF 是单台服务器的平均故障间隔时间。广播时间应比选举超时短一个数量级，以便领导者能够可靠地发送保持跟随者不发起选举的心跳消息；鉴于使用了随机化的选举超时方法，这个不等式也使得分裂投票变得不太可能。选举超时应比 MTBF 短几个数量级，以便系统能够稳步前进。当领导者崩溃时，系统将会在大约选举超时的时间内不可用；我们希望这只占总体时间的一小部分。

广播时间和 MTBF 是底层系统的属性，而选举超时是我们需要选择的。Raft 的 RPC 通常需要接收者将信息持久化到稳定存储中，因此广播时间可能从 0.5 毫秒到 20 毫秒不等，具体取决于存储技术。因此，选举超时可能在 10 毫秒到 500 毫秒之间。典型的服务器 MTBF 是几个月或更长，这很容易满足时间要求。

## 6 Cluster membership changes

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240828231022294.png" alt="image-20240828231022294" style="zoom:50%;" />

> 图10：直接从一个配置切换到另一个配置是不安全的，因为不同的服务器会在不同的时间进行切换。在这个例子中，集群从三个服务器扩展到五个服务器。不幸的是，在某个时间点，可能会出现两个不同的领导者被选举出来的情况，一个是旧配置（Cold）中的多数，另一个是新配置（Cnew）中的多数。

