# Raft

# CH-1 Introduction

PAXOS很难理解,所以发明了Raft，解决这个问题

1. Raft共识算法的提出

   Raft 是一种用于管理复制日志的共识算法，尽管其效率与 Paxos 相当，但结构上有所不同，使其更易于理解，且为构建实际系统提供了更好的基础。

2. 设计目标

   Raft 的主要设计目标是提升算法的可理解性，以便于系统构建和教育。因此，Raft 将共识过程的关键元素（如Leader选举、日志复制和安全性）分解开来，减少了需要考虑的状态数量。

3. Raft的关键特性
   - 强领导机制：Raft使用比其他共识算法更强的领导机制，例如，日志条目仅从Leader流向其他服务器，这简化了日志管理，使Raft更易理解。
   - Leader选举：Raft通过随机计时器选举Leader，仅需在任何共识算法中都必需的心跳机制上增加少量机制，从而简单快速地解决冲突。
   - 集群成员变更：Raft 引入了一种新的集群成员变更机制，使用重叠多数派以确保在配置变更期间集群能正常运行。

# CH-2 Replicated state machines

> 复制状态机简介

1. Replicated state machines常用在分布式环境，解决多节点数据一致性问题

2. replicated log：在复制状态机中，每个服务器存储一个日志，包含了从客户端接收到的命令。这些命令按顺序在状态机中执行，确保所有服务器的状态保持一致。

   > 若每个服务器日志的条目和顺序都相同，那么当状态机执行完日志时，最终状态也会相同。

   <img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425120056892.png" alt="image-20230425120056892" style="zoom:50%;" align="left"/>

3. 一致性算法的主要工作就是保证所有服务器的日志保持一致
4. 一致性算法的特性
   - 安全性：在所有非拜占庭条件下保证安全，即使在网络延迟、分区、丢包、重复和重排序的情况下也不会返回错误结果。
   - 可用性：只要多数服务器正常工作并能够互相通信，系统就能继续运行。
   - 时间独立性：算法的一致性不依赖于时间，即使时钟故障或消息极端延迟，最多也只会导致可用性问题。
   - 性能：在常规情况下，一旦集群中的多数服务器响应远程过程调用，命令就可以完成，少数慢速服务器不会影响整体系统性能。

>拜占庭环境:
>
>指分布式系统中存在节点以恶意方式进行操作，比如向其他节点发送错误信息，试图破坏系统的一致性和可靠性。
>
>在Raft论文中，作者假设系统中的节点不会出现拜占庭故障。他们关注的是一些常见的故障情况，如节点崩溃、网络分区、消息延迟等。这些故障可以由诸如硬件故障、网络故障或软件错误等原因引起。

# CH-3 What’s wrong with Paxos?

> Paxos的缺陷

- 不好用
- 不好理解

# CH-4 Designing for understandability

> 设计Raft时，为了容易理解做了哪些努力

# CH-5

> Raft算法介绍

## Raft概述

1. 首先通过选举，选出一个特定节点做Leader，将`管理日志`的职责全部交给该Leader。

2. Leader接收Client的日志，并将其复制到其他Server，在安全时告知其他Server执行日志。

   Leader机制简化了日志的管理。例如，Leader可以自行决定新条目在日志中的位置，并且数据只从Leader流向Server，简单明了。

   Leader可能会失效，或与其他Server断开连接，这种情况下系统会选出新的Leader
   

Raft将一致性问题分解为三个独立子问题

  - `Leader选举`：Leader失效时，必须能选出新Leader（5.2节）
  - `日志复制`：Leader接收来自Client的日志条目，并在集群中进行复制，让其他Server的日志和自己一致（5.3节）
  - `安全性`：Raft的关键安全性属性是状态机安全性属性，如图3所示：集群中所有服务器不仅日志一致，执行的状态也需一致，比如都执行完了第10条日志，第5.4节描述了Raft如何确保此属性；解决方案包括对第5.2节中描述的选举机制施加额外的限制。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240829012226487.png" alt="image-20240829012226487" style="zoom:50%;" />

### 状态

| 所有server都有的持久化状态           | 先存储，然后响应RPC                                          |
| ------------------------------------ | ------------------------------------------------------------ |
| currentTerm                          | 当前任期，初始为0，单调递增                                  |
| votedFor                             | 当前任期自己投的候选人的`candidateId`，没有就是null          |
| log[]                                | log条目集，每个条目都包含状态机的命令，以及Leader收到条目时的任期，首个条目的index为1 |
| **所有server都有的Volatile state：** |                                                              |
| commitIndex                          | 被提交的最大日志条目的index，初始为0                         |
| lastApplied                          | 被应用到状态机的日志条目的index，初始为0                     |
| **Leader独有的Volatile state:**      |                                                              |
| nextIndex[]                          | 对于每个server，下次要发送的日志条目的起始index，起始为`Leader last log index + 1` |
| matchIndex[]                         | 对于每个server，已复制的最高日志条目的index，初始为0。       |

### AppendEntries RPC，用于追加日志

> 1. 由Leader发起，发送给follower，用于复制日志条目(§5.3)
> 2. 也用于心跳连接(§5.2)

| Arguments    |                                                             |
| ------------ | ----------------------------------------------------------- |
| term         | Leader 任期                                                 |
| leaderId     | follower可通过这个重定向其他client的请求到Leader            |
| prevLogIndex | 前一个日志的index                                           |
| prevLogTerm  | 前一个日志的term                                            |
| entries[]    | 日志条目，心跳时为空                                        |
| leaderCommit | leader的commit Index                                        |
| **Results:** |                                                             |
| term         | 用于Leader的更新                                            |
| success      | 如果follower的日志和prevLogIndex、prevLogTerm匹配就返回true |

**Receiver implementation**

1. 如果Leader的任期小于follower的任期，返回false

2. 如果follower和`prevLogIndex`、`prevLogTerm`匹配失败，返回false

3. 如果follower的日志和Leader发来的日志冲突（比如相同的index，不同的任期），则删除自己的日志，用Leader发来的替换掉。

4. 只添加没有的日志

5. `If leaderCommit > commitIndex：`

   `set commitIndex = min(leaderCommit, index of last new entry)`

### RequestVote RPC

> 由Candidate发起，收集投票(§5.2).

| Arguments    | -                                      |
| ------------ | -------------------------------------- |
| term         | Candidate的当前任期                    |
| candidateId  | 用以说明谁在请求选票                   |
| lastLogIndex | Candidate最后一个日志项目的index(§5.4) |
| lastLogTerm  | Candidate最后一个日志项目的任期(§5.4)  |
| **Result**   |                                        |
| term         | 当前任期                               |
| voteGranted  | 是否投票                               |

**Receiver implementation:**

1. `if term < currentTerm: return false`(§5.1)
2. 如果`votedFor`是 null 或 candidateId，并且候选人与接收人的日志一样是最新的，则投票(§5.2, §5.4)。

### Rules for Servers

**All Servers:**

1. `If commitIndex > lastApplied`: 增加lastApplied，将log应用到状态机(§5.3)
2. 如果RPC的请求或者回复中包含的term大于自身term：则更新自己的term，并将自己转为follower状态(§5.1)

**Followers:**

1. 回应来自候选人和leader的RPC
2. 如果选举超时，没有收到现任Leader的AppendEntries RPC，也没有投票出去(不是收到投票请求，是投票出去)时，转换为候选人

**Candidates:**

1. 转换为候选人状态后，启动选举：
   - 增加当前任期
   - 投票给自己
   - 重置选举超时时间
   - 发送RequestVote RPC给其他所有服务器
2. 如果收到了超过半数的投票，成为Leader
3. 如果RPC被Leader接收到，停止选举，转换回follower
4. 如果选举时超时，再次启动选举

**Leaders:**

1. 当选举完成后：向每个服务器发送初始的空AppendEntries RPC(心跳)；在空闲期间重复发送以防止选举超时。(§5.2)
2. 如果收到来自客户端的指令: 添加指令到本地日志，待条目应用到状态机后再响应(§5.3)
3. If last log index ≥ nextIndex for a follower: 发送 AppendEntries RPC 并附上从nextIndex开始的 log entries 
   - If successful: 更新 nextIndex 和 matchIndex (§5.3)
   - If AppendEntries fails because of log inconsistency: 减小nextIndex并重试(§5.3)
4. 如果存在一个N，使得N>commitIndex，大多数的matchIndex[i]≥N，并且log[N].term == currentTerm：设置commitIndex = N (§5.3, §5.4).

## 5.1 Raft Basics

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230516181832398.png" alt="image-20230516181832398" style="zoom:50%;" align="left"/>

> - 选举安全性：
>
>  在给定的任期内最多只能选出一位领导人。§5.2
>
> - 领导人只附加原则：
>
>  领导人从不覆盖或删除其日志中的条目；它只附加新条目。§5.3
>
> - 日志匹配：
>
>  如果两个日志在同一索引和任期内包含相同的条目，那么这些日志在该索引及之前的所有条目中都是相同的。§5.3
>
> - 领导人完整性：
>
>  如果在某一任期内提交了一个日志条目，那么该条目将在所有后续任期的领导人的日志中存在。§5.4
>
> - 状态机安全性：
>
>  如果服务器在给定索引处将日志条目应用于其状态机，则其他服务器永远不会为该索引应用不同的日志条目。§5.4.3

1. 集群由多个服务器组成，通常为5个，这样系统可以容忍最多2个发生故障。

2. 服务器状态

   - `Leader`：集群中只有一个，处理所有客户端请求（如果客户端联系`Follower`，`Follower`会将其重定向到`Leader`）。

   - `Follower`：不会主动发出请求，只被动的响应`Leader`和`Candidate`的请求。

   - `Candidate`：当现任`Leader`失效时，`Follower`将转变为`Candidate`，发起选举以选出新`Leader`。

     <img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425151508108.png" style="zoom:50%;" align="left"/>
     
     图四：服务器状态及其转换

3. 任期机制

   Raft将时间划分为多个任期，每个任期从一次选举开始，一个或多个Candidate尝试成为Leader。选举获胜的Candidate将在整个任期内担任Leader。

4. 任期的作用

   任期编号充当Raft中的逻辑时钟，允许服务器检测过时的信息（如旧的Leader）。服务器之间通信时会交换当前任期号，服务器会根据最新的任期号更新自己。如果Leader或Candidate发现自己的任期已过时，会立即转换为`Follower`。

5. RPC通信

   Raft使用RPC进行服务器间的通信，基本的共识算法只需要两种RPC：

   - RequestVote：由Follower在选举时发起
   - AppendEntries：由Leader发起，用于复制日志条目和发送心跳信号

第7节添加了第3种RPC,用于在服务器之间传输快照。

如果服务器接收响应超时，它们会重新尝试RPC，并且会并行进行RPC以获得最佳性能。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425152532222.png" alt="image-20230425152532222" style="zoom:50%;" align="left"/>

> 图5：时间被分成了任期，每个任期都以选举开始。选举将产生一个Leader，它将管理集群直到任期结束。有时选举会失败

## 5.2 Leader选举

**0.新服务器加入集群**

服务器在启动时状态是Follower。只要服务器持续接收到Leader或Candidate的心跳信息，就会继续保持Follower状态。

**1.开始选举：**

Follower通过`选举超时(election timeout)`的时间间隔来决定是否启动选举。

如果在`选举超时`时间内未收到有效的心跳RPC（一般是不包含日志条目的`AppendEntries RPC`），则认为当前没有可用的Leader，开启选举。

> Raft通过使用随机化的选举超时来减少选票分裂的可能性，选举超时在一个固定的时间区间内随机选择（例如，150-300毫秒），这使得大多数情况下只有一个服务器超时并发起选举，赢得选举并在其他服务器超时前发送心跳信号。

**2.投票规则**

当服务器收到`RequestVote RPC`时，根据以下规则进行投票：

- 如果收到的RPC的任期小于服务器当前的任期：拒绝投票。
- 如果服务器已经为当前任期投过票，或收到的RPC中的日志不如自己的日志新（即最后一个条目的任期较旧或者任期相同但是编号较小），也会拒绝投票。
- 如果以上条件都不满足，服务器会为候选人投票，并重置自己的选举超时时间。

**3.选举结果**

- 如果候选人获得了集群中大多数服务器的选票，那么候选人赢得选举，立即成为新的Leader。它会向所有其他服务器发送心跳消息，以防止新的选举。
- 如果在选举过程中，候选人收到了来自其他服务器的心跳信息，且该服务器的任期大于等于候选人的任期，那么候选人会承认新Leader的合法性并转回Follower状态。
- 如果选举超时，且没有选出Leader，那么候选人会重置超时时间并触发新一轮选举。

**4.Candidate状态**

如果Candidate收到来自Leader的心跳信息，并且其任期大于等于Candidate的任期，则Candidate转回Follower状态

如果任期小于Candidate的任期，则继续进行选举

**5.无法获胜**

还有一种情况，就是没有一个Candidate获胜，一般是因为同时有多个Follower成为了Candidate，因此没人获得多数票。

这种情况，Candidate会等待一个随机的`选举超时`时间，增加任期，重新开始新一轮选举。

**6.Leader处理日志不一致**

- 领导者通过强制跟随者的日志与自己的日志一致来处理不一致性。领导者会查找最后一个一致的日志条目，并删除跟随者在该点之后的任何条目，然后将自己之后的所有条目发送给跟随者。
- 领导者为每个跟随者维护一个nextIndex，表示下一个要发送给该跟随者的日志条目的索引。如果日志不一致，领导者会递减nextIndex并重试AppendEntries RPC，直到日志一致为止。

**7.优化建议**：

通过让Follower在拒绝AppendEntries请求时返回冲突条目的任期号和该任期的第一个索引，来减少日志不一致的情况下被拒绝的次数。这样可以使领导者跳过所有冲突条目，仅用一次RPC就解决一个任期的冲突。

## 5.3 Log replication

### 复制流程

1. 一旦成为Leader，就开始处理客户端请求。每个客户端请求包含一个要由复制状态机执行的命令。
2. Leader将命令追加到其日志中。日志条目包含命令和任期编号。
3. Leader并行地向所有Follower发送AppendEntries RPC，其中包含待复制的日志条目、新条目前一个日志条目的索引和任期。
4. Follower收到`AppendEntries RPC`后，首先检查其中的前一个日志条目的索引和任期是否与自己的日志相匹配。如果匹配，Follower会添加新条目，并回复成功。如果不匹配，Follower将拒绝并回复失败。
5. 一旦Leader收到大多数Follower(包括Leader在内的半数以上，比如5个中的3个)的确认，日志条目就被认为是safely replicated。
6. safely replicated后，Leader会将执行条目到自己的状态机，即Commited，之后，它并不直接向Follower节点发送命令以执行该条目，只会更新已执行的最大索引编号index，在下次与follower沟通时，会把index附上，这样follower就知道index之前的所有条目都已执行。
7. **返回结果**：Leader在应用已提交日志条目到状态机后，会将操作结果返回给客户端。此时，分布式系统中的大多数服务器已达成一致并成功执行了客户端请求的操作。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425171710770.png" alt="image-20230425171710770" style="zoom:50%;" align="left"/>

<div align="center"><font color="green">图6：日志由按顺序编号的条目组成。每个条目包含创建它的任期（方框中的数字）和命令信息。如果一个条目可以安全地应用于状态机，那么它被认为是已提交的。</font></div>

### AppendEntries RPC中的元素

1. **Term**: 任期，用于检测Leader是否有效
2. **Leader ID**: Leader的标识符，以便Follower能够重定向客户端。
3. **PrevLogIndex**: 紧接在新日志之前的日志条目的索引
4. **PrevLogTerm**: 紧接在新日志之前的日志条目的任期，和PrevLogIndex结合. 用于检查Leader和Follower之间的日志是否一致。
5. **Entries[]**:  日志条目。心跳时这个可能是空的，这是一种特殊的AppendEntries RPC，不包含任何新的条目。
6. **LeaderCommit**:  Leader执行过的日志的最大Index。Follower会将这个Index及之前的日志应用于其状态机

返回给Leader的元素

1. **Term**: Follower的当前任期，供Leader自我更新。
2. **Success**:一 个布尔值，表示Follower的日志条目是否与Leader的条目相匹配。如果吻合，Follower会添加新的条目。如果不匹配，Follower拒绝RPC，Leader将递减prevLogIndex并重试。

**Raft会时刻保持以下属性，它们共同构成了图3中的Log Matching属性： **

- 如果日志中的两个条目具有相同的索引和任期，那么它们存储的是同一个命令。

- 如果日志中的两个条目具有相同的索引和任期，那么此条目之前的所有条目都是相同的。

证明如下：

1. 第一个属性源于一个事实：Leader在任期中创建的条目，index都是唯一的，而且index永远不会改变
2. 第二个属性由AppendEntries执行的一致性检查保证：当发送AppendEntries RPC时，其中包含了新条目之前条目的索引和任期。Follower在收到请求后会进行检查，如果没有找到相同索引和任期的条目，那么它将拒绝新条目。

总结：日志的初始空状态时，满足Log Matching，增加日志时，一致性检查会检查Log Matching属性。因此，每当 AppendEntries 返回成功时，Leader就知道Follower的日志与自己的日志完全一致。

### 日志修复

正常情况下，Leader和Follower的日志一致，所以能通过一致性检查。然而，Leader的崩溃会使日志不一致（老Leader还没有完成日志同步就崩溃了）。这些不一致会在多次崩溃中加剧。图7给出了一些案例。Follower可能会丢失Leader的条目，可能会有Leader没有的额外条目，或者两者都有。日志中缺失和多余的条目可能跨越多个任期。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425175616580.png" alt="image-20230425175616580" style="zoom:50%;" align="center"/>

<div align = "center"><font color = "green">图7：当顶部的Leader当权时，Follower日志中可能出现(a–f)中的任何一种情况。每个方框代表一个日志条目；方框中的数字是其任期。Follower可能会缺少条目（a–b），可能有额外的未提交条目（c–d），或者两者兼有（e–f）。例如，情况（f）可能发生在服务器成为第2个任期的Leader后，向其日志中添加了几个条目，然后在提交它们之前崩溃；它很快重新启动，成为第3个任期的Leader，并向其日志中添加了几个更多的条目；在第2个任期或第3个任期的任何条目被提交之前，该服务器再次崩溃，并持续停机了几个任期。</font></div>

在Raft中，Leader会强制Follower的日志与自己的日志保持一致。Follower日志中的冲突条目将会被Leader日志覆盖。第5.4节将进行说明：在加上另一个限制条件时，这个做法是安全的。

同步日志步骤：

1. 找到最后一条共有的日志条目，Follower删除之后所有的条目

2. 向Follower发送之后的所有日志条目。

   所有这些操作都是响应于AppendEntries RPC执行的一致性检查。Leader为每个Follower维护一个nextIndex，即Leader将要发送给follower的下一个日志条目的索引。

   Leader第一次当选时，

   1. 将所有Follower的nextIndex值（自己维护的）初始化为最后一个条目之后的索引（图7中的位置11）
   2. 如果主从日志不一致，则在下一个AppendEntries RPC中，一致性检查将失败。
   3. 之后，Leader会减少nextIndex并重试AppendEntries RPC。
   4. 最终，nextIndex将减少到Leader和Follower日志中最大匹配的位置点。此时AppendEntries成功。

3. 之后删除Follower日志中所有的冲突条目，并将Leader日志发送过去（如果有的话）。

因此，一旦AppendEntries成功，Follower的日志就会与Leader的日志一致，并将在任期内始终保持一致。

通过这种机制，Leader在掌权时不需要采取任何特殊措施来恢复日志一致性。只需正常操作，日志会在AppendEntries一致性检查失败的情况下自动修复。Leader永远不需要覆盖或删除自己日志中的条目（图3中的Leader仅附加属性）。

上述日志复制机制展现了第2节中描述的理想的共识属性：只要大多数服务器正常运行，Raft就可以接受、复制和应用新的日志条目；在正常情况下，一个新的条目可以通过向大多数集群进行一轮RPC复制；单个缓慢的Follower不会影响性能。

## 5.4 Safety

之前的章节描述了Raft的选举过程和复制日志过程。然而，到目前为止描述的机制还不足以确保状态的一致。

例如，当Leader提交了多个日志条目时，一个Follower可能不可用，然后被选为Leader，并用新的日志条目覆盖这些条目；结果，状态出错。本节将添加一些限制，完善Raft算法

1. 限制选举资格。Leader必须包含之前所有已提交的日志条目（从图3中的“Leader完备性”可知）。
2. 明确提交规则。

最后，我们提供“Leader完备性”的证明草图，展示它是如何确保状态机的正确性的。

### 5.4.1 选举限制

对于Raft，日志条目只从Leader流向Follower，Leader永远不会覆盖其日志中的现有条目。

Raft在投票阶段就添加了限制，防止未包含所有已提交条目的Candidate赢得选举：

1. RequestVote RPC中包含有关Candidate日志的信息，当收到投票请求时，接收方会将日志信息和自己本地的日志进行对比
2. 如果对方的日志比自己的新，那就投票给他，反之拒绝投票

日志“新”的定义：比较日志的最后一个条目，先比较任期，再比较索引。

### 5.4.2 提交之前任期的条目

如5.3节所述，当一个条目已存储到大多数服务器上时，就可以说该条目已提交。如果Leader在提交一项条目之前崩溃，未来的Leader将尝试完成该条目的复制。然而，一个来自以前任期的，已被存储在大多数服务器上的条目，Leader仍不能认为该条目已被提交。图8说明了这种情况，旧的日志条目存储在大多数服务器上，但仍然被未来的Leader覆盖。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230427152026231.png" alt="image-20230427152026231" style="zoom:50%;" align="left"/>

> 图8：一个时间序列显示了为什么Leader不能使用较早任期的日志条目来确定提交。在（a）中，S1是Leader，并部分复制了2号条目。在(b)中，S1崩溃了；S5凭借S3、S4和自己的投票当选为第三任期的Leader，并接受了日志索引2的不同条目。在（c）中，S5崩溃了；S1重新启动，被选为Leader，并继续复制。此时，第2项的日志条目已经在大多数服务器上复制，但它没有被提交。如果S1像(d)那样崩溃，S5可以被选为Leader（有S2、S3和S4的投票），并用它自己的第3学期的条目覆盖该条目。然而，如果S1在崩溃前在大多数服务器上复制了其当前任期的条目，如(e)，那么这个条目就被提交了（S5不能赢得选举）。此时，前面的条目都会被提交。

为了消除类似图8中的问题，Raft不会使用计数副本规则提交来自以前任期的日志条目。只有Leader当前任期的日志条目通过计数副本规则来提交；一旦这样提交了当前任期的一项条目，因为**Log Matching Property**性质，那么就可以认为所有先前的条目都间接地提交了。

>Log Matching Property：
>
>如果两个日志在某个索引处具有相同的任期和索引，那么在该索引之前的所有条目会是相同的，不会存在差异。

### 5.4.3 安全性证明

Leader Completeness：如果一个日志条目已被提交，那么这个条目将会出现在所有后续任期的Leader日志中。
