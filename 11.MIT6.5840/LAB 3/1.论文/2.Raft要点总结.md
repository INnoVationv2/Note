# Raft

# CH-1 Introduction

PAXOS很难理解,所以发明了Raft，解决这个问题

1. Raft共识算法的提出

   Raft 是一种用于管理复制日志的共识算法，尽管其效率与 Paxos 相当，但结构上有所不同，使其更易于理解，且为构建实际系统提供了更好的基础。

2. 设计目标

   Raft 的主要设计目标是提升算法的可理解性，以便于系统构建和教育。因此，Raft 将共识过程的关键元素（如Leader选举、日志复制和安全性）分解开来，减少了需要考虑的状态数量。

3. Raft的关键特性
   - 强领导机制：Raft使用比其他共识算法更强的领导机制，例如，日志条目仅从Leader流向其他服务器，这简化了日志管理，使Raft更易理解。
   - Leader选举：Raft通过随机计时器选举Leader，仅需在任何共识算法中都必需的心跳机制上增加少量机制，从而简单快速地解决冲突。
   - 集群成员变更：Raft 引入了一种新的集群成员变更机制，使用重叠多数派以确保在配置变更期间集群能正常运行。

# CH-2 Replicated state machines

> 复制状态机简介

1. Replicated state machines常用在分布式环境，解决多节点数据一致性问题

2. replicated log：在复制状态机中，每个服务器存储一个日志，包含了从客户端接收到的命令。这些命令按顺序在状态机中执行，确保所有服务器的状态保持一致。

   > 若每个服务器日志的条目和顺序都相同，那么当状态机执行完日志时，最终状态也会相同。

   <img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425120056892.png" alt="image-20230425120056892" style="zoom:50%;" align="left"/>

3. 一致性算法的主要工作就是保证所有服务器的日志保持一致
4. 一致性算法的特性
   - 安全性：在所有非拜占庭条件下保证安全，即使在网络延迟、分区、丢包、重复和重排序的情况下也不会返回错误结果。
   - 可用性：只要多数服务器正常工作并能够互相通信，系统就能继续运行。
   - 时间独立性：算法的一致性不依赖于时间，即使时钟故障或消息极端延迟，最多也只会导致可用性问题。
   - 性能：在常规情况下，一旦集群中的多数服务器响应远程过程调用，命令就可以完成，少数慢速服务器不会影响整体系统性能。

>拜占庭环境:
>
>指分布式系统中存在节点以恶意方式进行操作，比如向其他节点发送错误信息，试图破坏系统的一致性和可靠性。
>
>在Raft论文中，作者假设系统中的节点不会出现拜占庭故障。他们关注的是一些常见的故障情况，如节点崩溃、网络分区、消息延迟等。这些故障可以由诸如硬件故障、网络故障或软件错误等原因引起。

# CH-3 What’s wrong with Paxos?

> Paxos的缺陷

- 不好用
- 不好理解

# CH-4 Designing for understandability

> 设计Raft时，为了容易理解做了哪些努力

# CH-5

> Raft算法介绍

## Raft概述

1. 首先通过选举，选出一个特定节点做Leader，将`管理日志`的职责全部交给该Leader。

2. Leader接收Client的日志，并将其复制到其他Server，在安全时告知其他Server执行日志。

   Leader机制简化了日志的管理。例如，Leader可以自行决定新条目在日志中的位置，并且数据只从Leader流向Server，简单明了。

   Leader可能会失效，或与其他Server断开连接，这种情况下系统会选出新的Leader
   

Raft将一致性问题分解为三个独立子问题

  - `Leader选举`：Leader失效时，必须能选出新Leader（5.2节）
  - `日志复制`：Leader接收来自Client的日志条目，并在集群中进行复制，让其他Server的日志和自己一致（5.3节）
  - `安全性`：Raft的关键安全性属性是状态机安全性属性，如图3所示：集群中所有服务器不仅日志一致，执行的状态也需一致，比如都执行完了第10条日志，第5.4节描述了Raft如何确保此属性；解决方案包括对第5.2节中描述的选举机制施加额外的限制。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20240829012226487.png" alt="image-20240829012226487" style="zoom:50%;" />

### 状态

| 所有server都有的持久化状态           | 先存储，然后响应RPC                                          |
| ------------------------------------ | ------------------------------------------------------------ |
| currentTerm                          | 当前任期，初始为0，单调递增                                  |
| votedFor                             | 当前任期自己投的候选人的`candidateId`，没有就是null          |
| log[]                                | log条目集，每个条目都包含状态机的命令，以及Leader收到条目时的任期，首个条目的index为1 |
| **所有server都有的Volatile state：** |                                                              |
| commitIndex                          | 被提交的最大日志条目的index，初始为0                         |
| lastApplied                          | 被应用到状态机的日志条目的index，初始为0                     |
| **Leader独有的Volatile state:**      |                                                              |
| nextIndex[]                          | 对于每个server，下次要发送的日志条目的起始index，起始为`Leader last log index + 1` |
| matchIndex[]                         | 对于每个server，已复制的最高日志条目的index，初始为0。       |

### AppendEntries RPC，用于追加日志

> 1. 由Leader发起，发送给follower，用于复制日志条目(§5.3)
> 2. 也用于心跳连接(§5.2)

| 参数         |                                                              |
| ------------ | ------------------------------------------------------------ |
| term         | Leader任期                                                   |
| leaderId     | Follower可通过这个重定向client的请求到Leader                 |
| prevLogIndex | 紧接在新日志之前的日志条目的索引                             |
| prevLogTerm  | 紧接在新日志之前的日志条目的任期                             |
| entries[]    | 日志条目，心跳时为空(为提高效率，可一次携带多个条目)         |
| leaderCommit | Leader的commitIndex                                          |
| **结果**     |                                                              |
| term         | Follower的Term，以便Leader更新自己                           |
| success      | 发来的日志是否匹配，是否接受日志，如果Follower的日志和prevLogIndex、prevLogTerm匹配就返回true |

**接收方(Follower)处理逻辑**

1. 若`term<CurrentTerm`，返回false

2. 若日志中没有与`prevLogIndex`、`prevLogTerm`匹配的项，返回false

3. 若Follower的日志和发来的日志冲突(比如日志条目的index相同，但term不同)，则删除现有的条目及后面所有的条目。

4. 将Leader发来的日志中，`自己没有的`追加到日志中，

5. If `leaderCommit>commitIndex：`

   set `commitIndex=min(leaderCommit, 最后一个新表项的索引)`

### RequestVote RPC

> 由Candidate发起，收集投票(§5.2).

| Arguments    | -                                      |
| ------------ | -------------------------------------- |
| term         | Candidate的当前任期                    |
| candidateId  | 用以说明谁在请求选票                   |
| lastLogIndex | Candidate最后一个日志项目的index(§5.4) |
| lastLogTerm  | Candidate最后一个日志项目的任期(§5.4)  |
| **Result**   |                                        |
| term         | 当前任期                               |
| voteGranted  | 是否投票                               |

**Receiver implementation:**

1. `if term < currentTerm: return false`(§5.1)
2. 如果`votedFor`是 null 或 candidateId，并且候选人与接收人的日志一样是最新的，则投票(§5.2, §5.4)。

### 各个Server要遵守的规则

**所有Server的规则:**

1. `If commitIndex > lastApplied`: 增加lastApplied，将log应用到状态机(§5.3)
2. 如果RPC的请求或者回复中包含的term大于自身term：则更新自己的term，并将自己转为follower状态(§5.1)

**Followers:**

1. 回应来自候选人和leader的RPC
2. 如果选举超时，没有收到现任Leader的AppendEntries RPC，也没有投票出去(不是收到投票请求，是投票出去)时，转换为候选人

**Candidates:**

1. 转换为候选人状态后，启动选举：
   - 增加当前任期
   - 投票给自己
   - 重置选举超时时间
   - 发送RequestVote RPC给其他所有服务器
2. 如果收到了超过半数的投票，成为Leader
3. 如果RPC被Leader接收到，停止选举，转换回follower
4. 如果选举时超时，再次启动选举

**Leaders:**

1. 当选举完成后：向每个服务器发送初始的空AppendEntries RPC(心跳)；在空闲期间重复发送以防止选举超时。(§5.2)
2. 如果收到来自客户端的指令: 添加指令到本地日志，待条目应用到状态机后再响应(§5.3)
3. If last log index ≥ nextIndex for a follower: 发送 AppendEntries RPC 并附上从nextIndex开始的 log entries 
   - If successful: 更新 nextIndex 和 matchIndex (§5.3)
   - If AppendEntries fails because of log inconsistency: 减小nextIndex并重试(§5.3)
4. 如果存在一个N，使得N>commitIndex，大多数的matchIndex[i]≥N，并且log[N].term == currentTerm：设置commitIndex = N (§5.3, §5.4).

## 5.1 Raft Basics

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230516181832398.png" alt="image-20230516181832398" style="zoom:50%;" align="left"/>

> - 选举安全性：
>
>  在给定的任期内最多只能选出一位领导人。§5.2
>
> - 领导人只附加原则：
>
>  领导人从不覆盖或删除其日志中的条目；它只附加新条目。§5.3
>
> - 日志匹配：
>
>  如果两个日志在同一索引和任期内包含相同的条目，那么这些日志在该索引及之前的所有条目中都是相同的。§5.3
>
> - 领导人完整性：
>
>  如果在某一任期内提交了一个日志条目，那么该条目将在所有后续任期的领导人的日志中存在。§5.4
>
> - 状态机安全性：
>
>  如果服务器在给定索引处将日志条目应用于其状态机，则其他服务器永远不会为该索引应用不同的日志条目。§5.4.3

1. 集群由多个服务器组成，通常为5个，这样系统可以容忍最多2个发生故障。

2. 服务器状态

   - `Leader`：集群中只有一个，处理所有客户端请求（如果客户端联系`Follower`，`Follower`会将其重定向到`Leader`）。

   - `Follower`：不会主动发出请求，只被动的响应`Leader`和`Candidate`的请求。

   - `Candidate`：当现任`Leader`失效时，`Follower`将转变为`Candidate`，发起选举以选出新`Leader`。

     <img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425151508108.png" style="zoom:50%;" align="left"/>
     
     图四：服务器状态及其转换

3. 任期机制

   Raft将时间划分为多个任期，每个任期从一次选举开始，一个或多个Candidate尝试成为Leader。选举获胜的Candidate将在整个任期内担任Leader。

4. 任期的作用

   任期编号充当Raft中的逻辑时钟，允许服务器检测过时的信息（如旧的Leader）。服务器之间通信时会交换当前任期号，服务器会根据最新的任期号更新自己。如果Leader或Candidate发现自己的任期已过时，会立即转换为`Follower`。

5. RPC通信

   Raft使用RPC进行服务器间的通信，基本的共识算法只需要两种RPC：

   - RequestVote：由Follower在选举时发起
   - AppendEntries：由Leader发起，用于复制日志条目和发送心跳信号

第7节添加了第3种RPC,用于在服务器之间传输快照。

如果服务器接收响应超时，它们会重新尝试RPC，并且会并行进行RPC以获得最佳性能。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425152532222.png" alt="image-20230425152532222" style="zoom:50%;" align="left"/>

> 图5：时间被分成了任期，每个任期都以选举开始。选举将产生一个Leader，它将管理集群直到任期结束。有时选举会失败

## 5.2 Leader选举

**0.新服务器加入集群**

服务器在启动时状态是Follower。只要服务器持续接收到Leader或Candidate的心跳信息，就会继续保持Follower状态。

**1.开始选举：**

Follower通过`选举超时(election timeout)`的时间间隔来决定是否启动选举。

如果在`选举超时`时间内未收到有效的心跳RPC（一般是不包含日志条目的`AppendEntries RPC`），则认为当前没有可用的Leader，开启选举。

> Raft通过使用随机化的选举超时来减少选票分裂的可能性，选举超时在一个固定的时间区间内随机选择（例如，150-300毫秒），这使得大多数情况下只有一个服务器超时并发起选举，赢得选举并在其他服务器超时前发送心跳信号。

**2.投票规则**

当服务器收到`RequestVote RPC`时，根据以下规则进行投票：

- 如果收到的RPC的任期小于服务器当前的任期：拒绝投票。
- 如果服务器已经为当前任期投过票，或收到的RPC中的日志不如自己的日志新（即最后一个条目的任期较旧或者任期相同但是编号较小），也会拒绝投票。
- 如果以上条件都不满足，服务器会为候选人投票，并重置自己的选举超时时间。

**3.选举结果**

- 如果候选人获得了集群中大多数服务器的选票，那么候选人赢得选举，立即成为新的Leader。它会向所有其他服务器发送心跳消息，以防止新的选举。
- 如果在选举过程中，候选人收到了来自其他服务器的心跳信息，且该服务器的任期大于等于候选人的任期，那么候选人会承认新Leader的合法性并转回Follower状态。
- 如果选举超时，且没有选出Leader，那么候选人会重置超时时间并触发新一轮选举。

**4.Candidate状态**

如果Candidate收到来自Leader的心跳信息，并且其任期大于等于Candidate的任期，则Candidate转回Follower状态

如果任期小于Candidate的任期，则继续进行选举

**5.无法获胜**

还有一种情况，就是没有一个Candidate获胜，一般是因为同时有多个Follower成为了Candidate，因此没人获得多数票。

这种情况，Candidate会等待一个随机的`选举超时`时间，增加任期，重新开始新一轮选举。

**6.Leader处理日志不一致**

- 领导者通过强制跟随者的日志与自己的日志一致来处理不一致性。领导者会查找最后一个一致的日志条目，并删除跟随者在该点之后的任何条目，然后将自己之后的所有条目发送给跟随者。
- 领导者为每个跟随者维护一个nextIndex，表示下一个要发送给该跟随者的日志条目的索引。如果日志不一致，领导者会递减nextIndex并重试AppendEntries RPC，直到日志一致为止。

**7.优化建议**：

通过让Follower在拒绝AppendEntries请求时返回冲突条目的任期号和该任期的第一个索引，来减少日志不一致的情况下被拒绝的次数。这样可以使领导者跳过所有冲突条目，仅用一次RPC就解决一个任期的冲突。

## 5.3 Log replication

### 复制流程

1. 一旦成为Leader，就开始处理客户端请求。每个客户端请求包含一个要由状态机执行的命令。

2. Leader将命令作为新条目追加到日志中。日志条目由命令和任期编号组成。

3. Leader向所有Follower`并行`发送AppendEntries RPC，其中包含待复制的旧条目、新条目、前一个日志条目的索引和任期。

4. Follower收到`AppendEntries RPC`后，先检查其中的`前一个日志条目的索引`和任期是否与自己的日志匹配。若匹配，则添加新条目并回复成功。若不匹配，则拒绝并回复失败。

5. 一旦Leader收到大多数Follower(包括Leader在内的半数以上)的确认，日志条目就被认为是`safely replicated`。

6. `safely replicated`后，Leader会执行条目到自己的状态机，即Commited，之后，它并不直接向Follower发送命令让其执行条目，只会将已执行的最大日志目录编号记录Index下来，下次与Follower通信时，会将Index附上，这样Follower就知道Index之前的条目都已执行，然后Follower就也会执行这些条目到自己状态机。

7. **返回结果**：Leader在将`Commited`日志条目执行到状态机后，会将操作结果返回给客户端。此时，分布式系统中的大多数服务器就已达成一致并成功执行了客户端的请求。

   <img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425171710770.png" alt="image-20230425171710770" style="zoom:50%;" align="left"/>

   > 图6：日志由按顺序编号的条目组成。每个条目包含创建它的任期（方框中的数字）和要执行的命令。如果一个条目可以安全地应用于状态机，那么它就被认为是`Commited`的。

**Raft会时刻保持以下属性，它们共同构成了图3中的Log Matching属性： **

>Log Matching: 如果两个日志中存在Index和term相同的条目，则日志在该条目之前的所有条目也都是相同的。

- 如果不同日志中的两个条目具有相同的Index和term，那么它们存储的是同一个命令。

- 如果不同日志中的两个条目具有相同的Index和term，那么此条目之前的所有条目都是相同的。

证明如下：

1. 第一个属性源于一个事实：Leader在任期中创建的条目，index都是唯一的，而且日志条目永远不会改变他们在日志中的位置。

2. 第二个属性由AppendEntries执行的一致性检查保证。当发送AppendEntries RPC时，其中包含了leader在其日志中找到的，新条目之前条目的Index和Term。如果follower在其日志中没有找到匹配的条目，则拒绝新条目。

   一致性检查的逻辑如下:日志的初始空状态满足日志匹配属性，无论何时扩展日志，一致性检查都将保持日志匹配属性。因此，每当AppendEntries成功返回时，Leader就知道Follower的日志在新条目之前的部分与自己的日志是相同的。

### 日志修复

正常运行时，Leader和Follower的日志一致，因此AppendEntries一致性检查不会失败。然而，Leader崩溃可能会导致日志不一致(旧leader可能没有完全复制日志中的所有条目)。这些不一致可能会在一系列的Leader和Follower崩溃中加剧。图7说明了追随者的日志可能与新领导者的日志不同的方式。Follower可能如果缺少leader上存在的条目、可能有leader上不存在的额外条目，或者两者都有。日志中缺失的和多余
的条目可能跨越多个Term。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230425175616580.png" alt="image-20230425175616580" style="zoom:50%;" align="center"/>

> 图7：
>
> 当顶部的Leader上台时，Follower日志中可能出现(a–f)中的任何一种情况。每个方框代表一个日志条目；方框中的数字是其任期。
>
> Follower可能会缺少条目(a–b)，可能有额外的未提交条目(c–d)，或者两者兼有(e–f)。例如，`场景f`可能发生在服务器成为第2个Term的Leader后，向其日志中添加了几个条目，然后在提交它们之前崩溃；它很快重新启动，成为第3个任期的Leader，并在其日志中添加了更多的条目；在第2或第3个任期的任何条目被提交之前，该服务器再次崩溃，并且在接下来的多个term内一直处于停机状态。

在Raft中，Leader通过强制Follower复制自己的日志保持一致。这意味着Follower日志中的冲突条目会被Leader日志覆盖。**第`5.4节`将说明：如果再加上一个限制，这是安全的。**

日志冲突处理步骤：

Leader为每个Follower维护一个nextIndex，这是Leader将发送给Follower的下一个日志条目的索引

Leader首次当选时，将所有nextIndex值初始化为日志中最后一个值之后的索引(图7中的11)。如果Follower与Leader的日志不一致，下一次AppendEntries RPC肯定会失败。失败后，Leader减少nextIndex并重试AppendEntries RPC。最终，nextIndex将达到Leader和Follower日志匹配的点。

成功匹配后，AppendEntries将成功，Follower将删除日志中的所有冲突条目，并从Leader日志(如果有的话)中追加条目。一旦AppendEntries成功，Follower与Leader的日志将一致，并且在该Term内始终保持一致。

> 如果需要，可以对协议进行优化，以减少被拒绝的AppendEntries rpc的数量。For example, when rejecting an AppendEntries request, the follower can include the term of the conﬂicting entry and the ﬁrst index it stores for that term. With this information, the leader can decrement nextIndex to bypass all of the conﬂicting entries in that term; one AppendEntries RPC will be required for each term with conﬂicting entries, rather than one RPC per entry。实际上，我们怀疑这种优化是否必要，因为故障很少发生，并且出现大量不一致条目的可能性很小。

通过这个机制，Leader不需要采取任何特殊措施，只需正常操作，日志会在AppendEntries一致性检查失败的情况下自动修复。Leader永远不会覆盖或删除自己日志中的条目(图3中的`Leader Append Only`属性)。

上述日志复制机制展现了第2节中描述的理想的共识属性：只要大多数服务器正常运行，Raft就可以接受、复制和应用新的日志条目；在正常情况下，一个新条目可以通过一轮rpc复制到集群的大多数;单个缓慢的Follower不会影响性能。

## 5.4 Safety

之前的章节描述了Raft的选举和复制日志过程。然而，到目前为止描述的机制还不足以确保每个状态机以相同的顺序执行完全相同的命令。

例如，当Leader提交多个日志条目时，一个Follower可能不可用，但是之后被选为Leader，并用新的条目覆盖了这些条目；本节将添加一些限制，完善Raft算法

1. 限制选举资格，确保任何Term的Leader包含之前Term中提交的所有条目(图3中的leader完整性属性)
2. 明确提交规则。
3. 给出`Leader完整性属性`的证明草图，展示它是如何确保状态机的正确性。

### 5.4.1 选举限制

在Raft中，日志条目只从Leader流向Follower，Leader永远不会覆盖其日志中的现有条目。

Raft在投票阶段添加限制，防止未包含所有已提交条目的Candidate赢得选举：

RequestVote RPC中包含有关Candidate日志的信息，当收到投票请求时，投票人会将Candidate日志和自己的日志进行对比，

- 如果Candidate的日志和投票人的至少一样新，投票
- 如果投票人的日志比Candidate更新，不投票

日志最新的定义：比较日志中最后一个条目的Index和Term来确定两个日志中哪一个是最新的。

### 5.4.2 前一个Term处于Committing阶段的日志项

如5.3节所述，leader一旦知道当前term的条目已存储在大多数服务器上时，就会将其提交。如果Leader在提交之前崩溃，未来的Leader将尝试完成复制该条目。然而，leader不能立即得出结论，认为上一个Term的条目一旦存储在大多数服务器上就是Commited的，图8说明了这种情况，旧的日志条目存储在大多数服务器上，但仍然被未来的Leader覆盖。

<img src="http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20230427152026231.png" alt="image-20230427152026231" style="zoom:50%;" align="left"/>

> 图8：一个时间序列显示了为什么Leader不能使用较早Term的日志条目来确定是否日志已被提交。
>
> 在(a)中，S1是Leader，并部分复制了2号条目。
>
> 在(b)中，S1崩溃了；S5凭借S3、S4和自己的投票当选为第三任期的Leader，并在索引为2处接收了不同条目。
>
> 在(c)中，S5崩溃了；S1重新启动，被选为Leader，并继续复制。此时，第2项的日志条目已经在大多数服务器上复制，但它没有被提交。
>
> 如果S1像(d)那样崩溃，S5可以被选为Leader(有S2、S3和S4的投票)，并用它自己的条目覆盖了其他条目。
>
> 如果如(e)那样，S1在崩溃前在大多数服务器上复制了其当前任期的条目，那么这个条目就被提交了(S5不能赢得选举)。此时，前面的条目都会被提交。

为消除图8中的问题，Raft从不通过计算副本数量(如果日志条目已复制到大多数服务器上，就可以提交该条目)来提交来自之前Term的日志条目。只有Leader当前任期的日志条目通过计算副本数量来提交；一旦当前Term的一个条目以这种方式提交，因为**Log Matching**属性，所有之前的条目都将间接提交。有些情况下，Leader可以安全地断定一个较旧的日志条目已被提交(例如，如果该条目存储在每个服务器上)，但为了简化处理，Raft 采取了更保守的方法。

>Log Matching：
>
>如果两个日志在某个索引处具有相同的任期和索引，那么在该索引之前的所有条目会是相同的，不会存在差异。

Raft在提交规则中引入了这种额外的复杂性，因为当Leader复制来自之前Term的条目时，这些日志条目保留了它们的原始任期号。在其他一致性算法中，如果一个新的Leader重新复制之前`Term`的条目，它必须使用其新的`任期号`来进行复制。Raft的方法使得推理日志条目变得更加容易，因为它们随着时间和在不同日志之间保持相同的任期号。此外，Raft中的新Leader发送的来自之前Term的日志条目比其他算法要少（其他算法必须发送冗余的日志条目来重新编号，然后才能提交）。

### 5.4.3 安全性证明

Leader Completeness：如果一个日志条目已被提交，那么这个条目将会出现在所有后续任期的Leader日志中。
